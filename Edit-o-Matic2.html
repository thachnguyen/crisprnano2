<html>
    <head>
<style>
/* --- Layout --- */
.column { float: left; width: 50%; }
.box { float: left; width: 30%; margin-right: 1%; }
.box1 { margin-left: 1%; }
.text-right { text-align: right; }
.hidden { display: none; }

/* --- Buttons --- */
button {
  background: rgba(38,170,220,0.3);
  border: none;
  border-radius: 3px;
  margin-top: 3px;
  padding: 3px;
  font-size: 12px;
  cursor: pointer;
}

/* --- Popup container --- */
.popup {
  position: relative;
  display: inline-block;
  cursor: pointer;
  user-select: none;
}
.popup .popuptext {
  visibility: hidden;
  width: 400px;
  background: rgb(191,185,245);
  color: #fff;
  text-align: left;
  border-radius: 6px;
  padding: 8px 1px;
  position: absolute;
  bottom: 125%;
  left: 10%;
  margin-left: -80px;
  z-index: 1;
}
.popup .popuptext::after {
  content: "";
  position: absolute;
  top: 100%;
  left: 50%;
  margin-left: -5px;
  border: 5px solid transparent;
  border-top-color: #b3acac;
}

/* --- Popup toggle/animation --- */
.popup .show {
  visibility: visible;
  animation: fadeIn 1s;
}
@keyframes fadeIn {
  from { opacity: 0; }
  to   { opacity: 1; }
}

/* --- Selector box --- */
div.selector {
  position: absolute;
  background: rgba(255,255,255,0.95);
  padding: 20px;
  line-height: 25px;
}
</style>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Edit-o-Matic</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.0/xlsx.full.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <link rel="stylesheet" href="./crisprnano2/bootstrap.min.css">
  <link rel="stylesheet" href="./crisprnano2/bootstrap-multiselect.css">
  <link rel="stylesheet" href="./crisprnano2/bootstrap-select.min.css">

  <link rel="stylesheet" href="./crisprnano2/all.min.css">
  <link rel="stylesheet" href="./crisprnano2/dataTables.bootstrap4.css">

  <!-- Intro.js -->
  <link rel="stylesheet" href="./crisprnano2/introjs.css">

  <!-- Custom styles -->
  <link rel="stylesheet" href="./crisprnano2/stylesBase.css">
  <link rel="stylesheet" href="./crisprnano2/myStyles.css">
  <link rel="stylesheet" href="./crisprnano2/stylesQuery.css">

        </head>
        <body>
            <nav class="navbar sticky-top navbar-expand-sm navbar-light">
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarToggler11" aria-controls="navbarToggler11" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarToggler11">
                    <ul class="navbar-nav  ml-auto">
                        <li class="nav-item mt-1">
                            <a href="https://www.crisprnano.de/Edit-o-Matic.html" class="nav-link">
                                <i class="fas fa-solid fa-user iconsMenu"></i>
                                Home
                            </a>
                        </li>
                        <li class="nav-item ml-2 mr-2 mt-1 " onclick="TabClicked(3)">
                            <a class="nav-link">
                                <i class="fas fa-solid fa-question iconsMenu"></i>
                                About
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>
            <div class="d-flex justify-content-center mt-3">
                <img id="titleIndex" width="60%" src="./crisprnano2/CRISPRnano2.png">
            </div>
     
        <div class="row">
            <div class="col-md-11" style="float:none;margin:auto;">
                <div class="card">
                    <br>
                    <div id="DIV_topmenu">
                        <div class="text-center">
                            <div class="btn-group btn-group-lg mr-3" role="group" id="aBtnGroup" aria-label="Basic example">
                                <button type="button"  name="setup" class="btn btn-info" onclick="TabClicked(0);">GENERAL ANALYZER</button>
                                <button type="button"  id="setup_PE" class="btn btn-info">PRIME EDITING ANALYZER</button>
                                <div id="save" style="display:none">test</div>
                                <button type="button"  name="result" class="btn btn-info" onclick="TabClicked(1);">RESULTS</button>
                                <button type="button"  name="bulkview_result" class="btn btn-info" onclick="TabClicked(4);">BULK/SINGLE CLONE VIEWER</button>
                                <button type="button"  name="offtarget_result" class="btn btn-info" onclick="TabClicked(5);">OFF-TARGET ANALYSIS</button>
                                <button type="button"  name="result" class="btn btn-info" onclick="TabClicked(2);">MANUAL</button>
                                <button type="button"  name="result" class="btn btn-info" onclick="TabClicked(6);">TEST DATA</button>
                                <button type="button" name="version" class="btn btn-info" onclick="TabClicked(10);"> VERSION </button>                                
                                <button type="button"  name="version" class="btn btn-info" onclick="TabClicked(9);">UTILITIES</button>
                            </div>
                        </div>
                    </div>
                </div>    
        <br>
        <div id="setup" style="position:center; top:80px">
                <br>
                <div class="row">
                <h3>Input data</h3>    
                <div class = "col-sm">
                    <label>
                        FASTQ Files (*): 
                    </label> 
                    <!-- <small class="text-muted">Uncompressed FASTQ output files from Illumina, ONT or PacBio. Make sure that the correct ordering is applied in the file browser. The file allocation to individual pie charts can be verified by the numbers given at alignment track.</small> -->
                </div>
                <div class = "col-sm">
                    <label>Data type:</label>                    <div class="popup" onclick="toggleHelp(1)">(? Click here!)
                        <span class="popuptext" id="help1">  <strong>Illumina:</strong> Very high base accuracy.<br>
                              <strong>Nanopore:</strong> Moderate accuracy, error-prone at the base level.<br>
                              <strong>Nanopore/PacBio Duplex:</strong> High accuracy, comparable to Illumina. Click again to close</span>
                    </div>
                    <!-- <small class="text-muted">Window size & indel rate parameter will be automatically adjusted</small> -->
                </div>
                <div class = "col-sm">
                    <label>Maximum expected genotype (ML mode only): </label> 
                    <div class="popup" onclick="toggleHelp(11)">(? Click here!)
                        <span class="popuptext" id="help11">We implemented a machine learning-assisted binary decision tree (BD tree) classifier, which enables rapid classification of sequencing reads while preserving high genotyping accuracy across diverse genome editing applications and sequencing platforms. We don't recommend to use machine learning mode if the indel is far away from cutting site  , Click again to close</span>
                    </div>
                </div>
                </div>
                <div class="row">
                    <div class = "col-sm">
                    <input type="file" id="files" class="form-control" name="files[]" multiple="">
                    </div>
                    <div class = "col-sm">
                    <select id="mySelect" onchange="setValue()" class="form-control">
                        <option value="illu">Illumina</option>
                        <option value="ont">Nanopore</option>
                        <option value="pacbio">PacBio or Nanopore Duplex</option>
                    </select>
                    </div>
                    <div class = "col-sm">
                        <input type="text" size="30" class="form-control" id= "ML_genotype" name="ML_genotype" value="10" onchange="checkValue();">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="" id="run_mode" checked>
                            <label class="form-check-label">
                              BOOSTING mode<br>
                              <small class="text-muted">Use machine learning classification model, faster but less accurate</small>
                            </label>
                        </div>
                        </div>
                </div>

                <div class="row">
                    <div class="col-sm-2">
                        <label>Gene Name:</label>
                    </div>
                    <div class="col-sm-2">
                        <label>gRNA library (automatic query)</label>
                    </div>

                    <div class="col-sm-4">
                        <label>gRNA/pegRNA (*): </label>
                        <div class="popup" onclick="toggleHelp(4)">(? Click here!)
                            <span class="popuptext" id="help4">
                                In this field, enter the nuclease target site. 
                                In the Prime Editing Analyzer, this corresponds to the pegRNA. 
                                Click again to close
                            </span>
                        </div>
                    </div>
                
                    <div class="col-sm-4">
                        <label>Insertion Sequence (for HDR / PE / BE)</label>  
                        <div class="popup" onclick="toggleHelp(2)">(? Click here!)
                            <span class="popuptext" id="help2">
                                <b>Advance features, please use Prime editing Analyzer</b><br>
                                <b>Edit Type:</b><br>
                                • <strong>Targeted Mutagenesis Oligonucleotide:</strong> Uses a repair template to introduce precise changes.<br>
                                • <strong>Prime Editing:</strong> Introduces small insertions, deletions, or substitutions.<br>
                                • <strong>Base Editing:</strong> Directly converts one base to another.<br>
                                Click again to close
                            </span>
                        </div>
                    </div>
                </div>
                
                <div class="row">
                    <div class="col-sm-2">
                      <input type="text" class="form-control" 
                             name="GeneName" id="GeneName"
                             placeholder="e.g. AHR"
                             oninput="FindGRNA(this.value);" 
                             onchange="getFastaSequence()" 
                             onblur="setTimeout('Hide_auto_complete();',500);">
                      <div id="gene_auto_complete" class="selector" style="display:none;"></div>
                    </div>
                  
                    <div class="col-sm-2">
                      <select id="lib_Select" class="form-control">
                        <option value="Lib Tkov">Toronto KnockOut (TKO) CRISPR Library - Version 3</option>
                        <option value="Lib Brunello">Human CRISPR Knockout Pooled Library (Brunello)</option>
                        <option value="Lib Bassik">Bassik Human CRISPR Knockout Library</option>
                      </select>
                    </div>
                  
                    <div class="col-sm-4">
                      <input type="text" class="form-control" name="RightBS" id="RightBS" value="">
                    </div>
                  
                    <div class="col-sm-4">
                      <input type="text" class="form-control" id="TargetingOligo" name="TargetingOligo" value="">
                      <div class="row mt-2">
                        <div class="col-sm-6">
                          <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="prime_editing">
                            <small class="text-muted">Knockin-only mode (exclude INDEL)</small>
                          </div>
                        </div>
                        <div class="col-sm-4">
                          <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="HA">
                            <small class="text-muted">Non-homology end joining KI</small>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                  
                
                <div class="hidden" id = "optional_para_Container_PE">
                    <h3>Options for Prime Editing</h3>
                <div class="row">   
                    <div class = "col-sm">
                        <label>Reverse Transcription Template (RTT)  </label>
                    </div>

                    <div class = "col-sm">
                        <label>Desired Edit  </label>
                        <!-- <small class="text-muted">Desired edit sequence (optional) is extra guide for annotate genotype</small> -->
                    </div>
                    <div class = "col-sm">
                        <label>Partial Edit  </label>
                        <!-- <small class="text-muted">Partial edit sequence (optional) is extra guide for annotate genotype</small> -->
                    </div>

                </div>
                <div class="row">   
                    <div class = "col-sm">
                        <input type="text" size="30" class="form-control" id = "RTT" name="RTT" >
                    </div>

                    <div class = "col-sm">
                        <input type="text" size="30" class="form-control" id = "d_edit" name="d_edit" >
                    </div>
                    <div class = "col-sm">
                        <input type="text" size="30" class="form-control" id = "p_edit" name="p_edit" >
                    </div>

                </div>
                <br>
                    <h5>Advanced options for Prime Editing</h5>
                    <small class="text-muted">These are specified for complexed Prime Editing settings </small>
                <div class="row">   
                    <div class = "col-sm">
                        <label>Prefix Reverse Transcription Template (RTT)  </label>
                        <!-- <small class="text-muted">RTT (optional) is secondary guide for insertion track</small> -->
                    </div>
                    <div class = "col-sm">
                        <label>Suffix Reverse Transcription Template (RTT)  </label>
                        <!-- <small class="text-muted">Desired edit sequence (optional) is extra guide for annotate genotype</small> -->
                    </div>
                    <div class = "col-sm">
                        <label>Primer Binding Site (PBS)  </label>
                        <!-- <small class="text-muted">Partial edit sequence (optional) is extra guide for annotate genotype</small> -->
                    </div>
                </div>
                <div class="row">   
                    <div class = "col-sm">
                        <input type="text" size="30" class="form-control" id = "preRTT" name="preRTT" >
                    </div>
                    <div class = "col-sm">
                        <input type="text" size="30" class="form-control" id = "sufRTT" name="sufRTT" >
                    </div>
                    <div class = "col-sm">
                        <input type="text" size="30" class="form-control" id = "PBS" name="PBS" >
                    </div>
                </div>

                </div>
                <h3 >Optional parameters</h3>
                <small id="optional_para" class="text-muted">
                    Click to expand
                    <img src="crisprnano2/expand.jpg" alt="icon" style="width:36px; height:36px; vertical-align:middle; margin-right:5px;">  
                </small>
                <br>
                <div id = "optional_para_Container" class="hidden">
                <div class="row">
                        <div class = "col-sm">
                            <label>Customized Sequence</label>               
                            <div class="popup" onclick="toggleHelp(3)">(? Click here!)
                                <span class="popuptext" id="help3">Reference amplicon length should be in the range of 200-300 bases with the nuclease target site located roughly in the middle. You can get the reference from Ensembl link below. Click again to close</span>
                            </div>

                        </div>
                        <div class = "col-sm">
                            <label>Interest region (optional) +/- bp </label>
                            <div class="popup" onclick="toggleHelp(5)">(? Click here!)
                                <span class="popuptext" id="help5"> For ONT reads, it is recommended to use -/+15 bases around the predicted DNA lesion. Larger regions are prone to false positive indels. Larger regions (total of 200-250 bp) can be safely used with Illumina reads. You can drag and drop the central point of the predicted double strand break in the genomic sequence to the left or to the right. Default value 0 is double strand breaking point- Edit-o-Matic will use the first index of sgRNA mapped on reference. Click again to close</span>
                            </div>
                        </div>
                        <div class = "col-sm">
                            <label>Indel Threshold [%]: </label>
                            <div class="popup" onclick="toggleHelp(9)">(? Click here!)
                                <span class="popuptext" id="help9">The Indel Threshold determines at what relative occurrence an individual indel mutation is considered as a unique allele of the respective clone analyzed, and is thus displayed in the alignment list. Low threshold values can result in false positive allele calling due to sequencing errors, whereas high threshold values result in false negative allele calling. Values in between 0 - 100 % can be entered. We recommend to use 5% for ONT reads and 2% for Illumina reads (default is set to 5%). Click again to close.</span>
                            </div> 
                        </div>
                        <div class = "col-sm">
                            <label>Phred Threshold: </label>
                            <div class="popup" onclick="toggleHelp(10)">(? Click here!)
                                <span class="popuptext" id="help10">The Quality threshold determine the minimum filter base, For Illumina it should be >20, For ONT it should be >10, Click again to close.</span>
                            </div>                         
                        </div>

                    </div>
                    <div class="row">   
                        <div class = "col-sm">
                            <input type="text" class="form-control" size="30" id="locus" name="Locus" value=""> 
                            <small class="text-muted">(if genename given, leave it blank):  
                            </small>
                        </div>
                        <div class = "col-sm">
                            <input type="text" size="30" name="region_analyse" id="region_analyse" value="100" class="form-control" onchange="checkValue();"><br>
                        </div>
                        <div class = "col-sm">
                            <input type="text" size="30" class="form-control" id= "allelethreshold" name="MutationThreshold" value="1" onchange="checkValue();"><br>
                        </div>
                        <div class = "col-sm">
                            <input type="text" size="30" class="form-control" id = "phredthreshold" name="Phred" value="20" onchange="checkValue();"><br>
                        </div>
                    </div>
                </div>
                <br>
                <div class="row">
                    <input type="submit" name="submit" value="SUBMIT" style="position:relative" class="btn btn-primary btn-lg" id="submit" onclick="Start();">
                    <div id="progress" style="display:none; padding: 10px; border: 10px solid #CCC; background: #EEE; width:40%; position:absolute; top:50%;left:40%">
                    </div>
                </div>
                <br>
                <br>
                <small class="text-muted">
                <a style="font-style: italic;">
                    Edit-o-Matic website is free and open to all users and there is no login required.<br>
                    To use Edit-o-Matic, you must enable JavaScript on your web browser.<br>
                    <!-- If you want to use CRISPRnano offline, please download </a><a href="https://iufduesseldorf-my.sharepoint.com/:u:/g/personal/thach_nguyen_iuf-duesseldorf_de/EeZRZlyFP31Gu-s-w57wlfEB42anCiwxbXRms_U_GAekpQ?e=YxlI2v"> the offline html file here.</a> <br> -->
                    <br>
                <a style="font-style: italic;"> (*) Mandatory <br>
                Question: thach.nguyen**(replace with email symbol)**iuf-duesseldorf.de
            </small>
            </div>
        </div>
    </div>
        <div id="about" style="position:center; top:80px; display: none;">
            <br>
            <br>
            <b>About:</b>
            <br>
            <br>Edit-o-Matic is a JavaScript-based program that was developed for rapid deep sequencing based genotyping of nuclease edited cell clones.  
            Edit-o-Matic supports noisy Oxford Nanopore but also Next Generation Sequencing (NGS) data such as Illumina and PacBio or Sanger Sequencing. <br> <br>
            Edit-o-Matic was developed by Dr. Thach Nguyen in the group of Dr. Andrea Rossi (GEMD lab) at Leibniz Research Institute for Environmental Medicine. The template web interface, data input, output are developed based on the template of Outknocker http://www.outknocker.org/. 
            <br>
            <br>
            <br><b>Licence:</b>
            <br>
            <br>Edit-o-Matic can be redistributed and/or modified under the terms of the GNU General Public License (Version 2), as published by the Free Software Foundation. A copy of the license can be found online at www.gnu.org/licenses. CRISPRnano is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose. See the GNU General Public License for more details.                <br>
 
            <br><br>
        </div>

        <div id="manual" style="position:center; top:80px; display: none;">
            <br>
            <h3>Edit-o-Matic manual</h3>
            Edit-o-Matic is a JavaScript-based program that was developed for rapid deep sequencing-based genotyping of nuclease edited cell clones. Edit-o-Matic supports noisy Oxford Nanopore but also Next Generation Sequencing (NGS) data such as Illumina, PacBio, or classic Sanger Sequencing.
            <p><mark>Detailed manual illustration in the pdf file below</mark></p>
            
            <p><b>Input data:</b><br>
            Edit-o-Matic webserver analyzes FASTQ output files from ONT, NGS, PacBio or Sanger systems.
            It analyzes multiple samples and currently supports up to 96 FASTQ files at the time.
            Please(!), make sure that the correct fils order is applied in the file browser.
            The file allocation to individual pie charts can be verified by the filename given at alignment track.</p>
            <p><b> Data type:</b> <br>
                Dependant on the sequencing datatype, the website will re-update the default parameters optimized for each datatype</p>
            <p><b>Reference sequences, Gene name and gRNA</b> <br>
            The reference sequence can be fetched from the genename (GENE SYMBOL in ENSEMBL) automatically. The recommended gRNA will be load when the genename is given.
            If you want to use your customized reference, please leave the Gene Name blank.</p>
            <p><b>Nuclease Target Site/gRNA</b> <br>
            The Nuclease Target site/gRNA is briefly checked if it is located within the reference genome.</p>
            <p><b>Interested region</b> <br>
            For ONT reads, it is recommended to use 90 bp predicted DNA lesion. Larger regions are prone to false positive indels. 
            Larger regions (total of 100-160 bp) can be safely used with Illumina reads. </p>
            <p><b>Targeting mutagenesis oligonucleotide</b> 
            <br>
            Donor oligonucleotide sequence is used to introduce a site-specific genomic modification. </p>
            <p></p><b>Indel Threshold</b> 
            <br>
            The Indel Threshold percentage determines at what relative occurrence an individual indel mutation is considered as a unique allele of the respective clone analyzed, and is thus displayed in the alignment list. 
            Low threshold values can result in false positive allele calling due to sequencing errors, 
            whereas high threshold values result in false negative allele calling. Values in between 0 - 100 % can be entered. We recommend using 5% for ONT reads and 2% for Illumina reads (the default is set to 5%).  <br><br>
        </p><br><b>Full manual: </b>
            <iframe src="./crisprnano2/manual.pdf" width="80%" height="2000px"></iframe>
        </div>
        <div id="testdata" style="position:center; top:80px; display: none;">
            <br>
            <br>
            <h3>TEST DATA</h3>
            
            <b>Code Availability </b> 
            <br>
            The source code for Edit-o-Matic is available at <a href="https://github.com/thachnguyen/CRISPRnano2">https://github.com/thachnguyen/CRISPRnano2</a> <br><br>
            
            <b>Test data </b> 
            <br>
            The lightweight test data for Edit-o-Matic is available at <a href="https://iufduesseldorf-my.sharepoint.com/:u:/g/personal/thach_nguyen_iuf-duesseldorf_de/ERPO_Y-8hg5Pq8KZv-OVNucBR211XB3UxcmxhzkBW8_gjg?e=K0tCeg">Lightweight Test Data.</a><br><br>
                <br>
                The full test data for Edit-o-Matic is available at <a href="https://iufduesseldorf-my.sharepoint.com/:u:/g/personal/thach_nguyen_iuf-duesseldorf_de/EV2AyPDA7lJKn9sXQPjLQR4B2WFcFEsO8vW8zqc2Uorr0g?e=tmPv6y">Full Test Data.</a><br><br>
                <b>
                Browser compatibility
        
            <table style="width:100%">
                <tbody><tr>
                    <td>OS</td>
                    <td>Version</td>
                    <td>Chrome</td>
                    <td>Firefox</td>
                    <td>Microsoft Edge</td>
                    <td>Safari</td>
                </tr>
                <tr>
                    <td>Linux</td>
                    <td>Ubuntu 20.04</td>
                    <td>Version 131.0.6778.108</td>
                    <td>98.0</td>
                    <td>n/a</td>
                    <td>n/a</td>
                </tr>
                <tr>
                    <td>MacOS</td>
                    <td>Monterey</td>
                    <td>Version 131.0.6778.108</td>
                    <td>98.0</td>
                    <td>n/a</td>
                    <td>15.3 </td>
                </tr>
                <tr>
                    <td>Windows</td>
                    <td>10</td>
                    <td>Version 131.0.6778.108</td>
                    <td>98.0</td>
                    <td>99.0.115039</td>
                    <td>n/a</td>
                </tr>
                </tbody></table>
            
        </div>

        <div id="Utility" style="position:center; top:80px; display: none;">
            <br>
            <br>
            <h3>Sequence manipulation tools</h3>
            
            <b>Single sequence manipulation </b> 
            <br>
            Single sequence manipulation at <a href="https://www.crisprnano.de/seq_tool.html">https://www.crisprnano.de/seq_tool.html</a> <br><br>
            
            <b>Fastq concentation files </b> 
            <br>
            Fastq concentation files is available at <a href="https://www.crisprnano.de/concat_list.html"> Concatenation list for pairend read files.</a><br><br>
        </div>

        <div id="version" style="position:center; top:80px; display: none;">
            <br>
            <h3>Reference:</h3>
            Nguyen, T., Ramachandran, H., Martins, S., Krutmann, J. and Rossi, A., 2022. Identification of genome edited cells using CRISPRnano. Nucleic Acids Research.<br>
            <br>
            Nguyen T.,, Ramachandran H.,, Binder S., Vykhlyantseva I., Krutmann J., Miccio A., Staerk C., Brusson M., Kontarakis Z., and Rossi A.
            Edit-o-Matic: A Streamlined Platform for Analyzing Prime and Other Genome Editing Outcomes
            <br>
            <br>
            The detail commit version is available at <a href="https://github.com/thachnguyen/crisprnano2/commits/main/">Version history</a> <br><br>
            
            <h4>Legacy </h4> 
            The first version of CRISPRnano is available at <a href="https://www.crisprnano.de/crisprnano1.html"> https://www.crisprnano.de/crisprnano1.html </a><br><br>
        
        </div>

        <div id="results"  class="box1" style="position:center; top:80px; display: none;">
            <div class="column">
                <div class="btn-group btn-group-lg mr-3" role="group" id="result_pie" >
                    <button type="button" class="btn btn-sm btn-light brd" name="setup" onclick="TabClicked(7)">GENOTYPE</button>
                    <button type="button" class="btn btn-sm btn-light brd" onclick="TabClicked(8)">RIMA</button>
                </div>
                <br>
                <br>
                <div id="DIV_piecharts" > 
                    <!-- //</div>style="position: absolute; left: 20px; top: 160px; display: none;"> -->
                    <svg id="SVGpie" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="900" height="520">
                    </svg>
                </div>
                <div id="DIV_piecharts_rima">
                <svg id="SVGpie_rima" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="900" height="520" style="display: none;">
                    </svg>
                </div>
                <div id="DIV_alignment">
                    <svg id="SVGmut" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1600" height="5000">
                    </svg>
                </div>

            </div>
            <div class="column" style="position:  absolute; left: 1000px;">
                <div class="btn-group btn-group-toggle" data-toggle="buttons">
                    <label class="btn btn-secondary" onclick="SaveProject();">
                       SAVE HTML
                    </label>
                    <label class="btn btn-secondary" onclick="SaveReport();">
                       Indel Excel
                    </label>
                    <label class="btn btn-secondary" onclick="SaveReportcsv();">
                       Indel CSV
                    </label>
                    <label class="btn btn-secondary" onclick="SaveSVGAlignment();">
                         Alignment (.svg)
                      </label>
                      <label class="btn btn-secondary" onclick="PrintSVG();">
                         Print PIE
                      </label>
                  </div> 
                <h3>SECONDARY ANALYSIS</h3> 
                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" id="bulkview">
                    <label class="form-check-label" for="bulkview">SWITCH TO SINGLE CLONE VIEW </label>
                    </div>
                    <small class="text-muted">NOTE: Click to the sample after selecting above option. Bulk view use lower percentage threshold</small>
                    <br>
                <h4>OFF TARGET Analysis (optional)</h4>    
                    List off-target Gene names (separate by ,):
                    <div class="popup" onclick="toggleHelp(8)">(? Click here!)
                        <span class="popuptext" id="help8">Name of the study genes, seperate by , . Click to close.</span>
                    </div>
                    <br>
                    
                    <input type="text" class="form-control" size="40" name="GeneName_list" id="GeneName_list" value="" onchange="checkOccurrence(); getFastaSequence_list();">
                    <small class="text-muted">Off-target analysis will check up to 4 other genes in a single run</small>
    
                    <br>
                    <button id="toggleButton" class="btn btn-sm btn-light brd">List of offset sgRNA:</button>
                    <br>
                    
                    <small class="text-muted">If off-target sgRNA empty, system will take the previous sgRNA to find region of interest</small>
                    <div id="sgRNAContainer" class="hidden">
                    <small class="text-muted">sgRNA gene 1</small>
                    <input type="text" class="form-control" size="40" name="sgRNA1" id="sgRNA1" value="" >
                    <small class="text-muted">sgRNA gene 2</small>
                    <input type="text" class="form-control" size="40" name="sgRNA2" id="sgRNA2" value="">
                    <small class="text-muted">sgRNA gene 3</small>
                    <input type="text" class="form-control" size="40" name="sgRNA3" id="sgRNA3" value="">
                    <small class="text-muted">sgRNA gene 4</small>
                    <input type="text" class="form-control" size="40" name="sgRNA4" id="sgRNA4" value="">
                    </div>
                    <br>

                    <input type="submit" name="submit" value="START OFFTARGET ANALYZER " class="btn btn-sm btn-light brd" id="submit" onclick="Start2();">
                    <br>
                    <br>
   
                    <div id="progress1" style="display:none; padding: 10px; border: 10px solid #CCC; background: #EEE; width:80%; position:absolute; top:40%;left:0%">
                    </div>
                        <br>
                </div>

            <div style="position:absolute; right:10%; top:0%" id="restart" align="right">

            </div> 
        </div>

        <div id="bulkview_result" style="position:center; top:80px; display: none;">
            <div id="DIV_piecharts_bulk" >
                <div>
                <div class="box">
                    <svg id="SVGpie_bulk" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="600" height="400"></svg>
                </div>
                <div class="box">
                    <svg id="RIMApie_bulk" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="400" height="400"></svg>
                </div>
                </div>
                <div>
                </div>
            </div>

            <div id="DIV_alignment_bulk" >
                <svg id="SVGmut_bulk" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1600";>
                </svg>
            </div>
            <div>
                <div id="Indel_plot" class = "box" style="width: 400px; height: 300px;"></div>
                <div id="QC_plot" class = "box" style="width: 400px; height: 300px;"></div>
                <div id="read_plot" class = "box" style="width: 480px; height: 300px;"></div>
                <div id="GC_plot" class = "box" style="width: 400px; height: 300px;"></div>
            </div>

        </div>

        <div id="offtarget_view" style="position:center; top:80px; display: none;">
            <div class="column">
                <div id="DIV_piecharts_off">
                    <svg id="SVGpie_off" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1600" height="420">
                    </svg>
                </div>
            </div>
            <div id="DIV_alignment_off">
                <svg id="SVGmut_off" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1600" height="5000">
                </svg>
            </div>
        </div>

</body>

<script>

//check input gene offtarget genes list
function checkOccurrence() {
    const inputValue = document.getElementById('GeneName_list').value;
    const targetString = ','; 
    const occurrenceCount = (inputValue.match(new RegExp(targetString, 'gi')) || []).length;
    if (occurrenceCount > 3) {
    alert(`Error: we only support maximum 4 off-target genes.`);
    }
} 

function getSeq(name){
    return document.getElementsByName(name)[0].value.replace(/[\s\n]+/g, '').toUpperCase();
}

// Get the input value and check their conditions
function checkValue() {
    const region_analyse1 = document.getElementsByName('region_analyse')[0].value;
    const MutationThreshold1 = document.getElementsByName("MutationThreshold")[0].value;
    const phred = document.getElementsByName("Phred")[0].value;
    const ML_genotype = document.getElementsByName("ML_genotype")[0].value;
    if (MutationThreshold1*1 > 100||MutationThreshold1*1<0.2) {
        alert('Please check the Mutation threshold again, supported range 0.2-100%');
        document.getElementsByName("MutationThreshold")[0].value = '2';
    }
    if (phred*1 > 60||phred*1<5) {
        alert('Please check this value again, Phred should be in range 5 to 60');
    document.getElementsByName("Phred")[0].value = '10';
    }
    if (region_analyse1*1 > 160||region_analyse1*1<60) {
        alert('System only support region size from 60-160 bp');
        document.getElementsByName('region_analyse')[0].value = "100";
    } 
    if (ML_genotype*1 > 20||ML_genotype*1<2) {
        alert('System only support maximum genotype between 2 to 20');
        document.getElementsByName('ML_genotype')[0].value = "10";
    } 
}

var bulk_threshold = 1; // Declare bulk_threshold globally

function setValue() {
    // Get the input value
    // Define the target string to check occurrence
    var mySelect = document.getElementById('mySelect');
    if (mySelect.value == 'ont'){
        document.getElementsByName('region_analyse')[0].value = "90";
        document.getElementsByName("MutationThreshold")[0].value = '5'
        document.getElementsByName("Phred")[0].value = '10'
        bulk_threshold = 1;
    }
    else {
        document.getElementsByName('region_analyse')[0].value = "100";
        document.getElementsByName("MutationThreshold")[0].value = '1'
        document.getElementsByName("Phred")[0].value = '20'
        bulk_threshold = 0.5;
    } 
}

//Drag and interactive

var AlignmentDragging = false, AlignmentLastX, AlignmentLastY, AlignmentStartPos = 0;

function AlignmentMouseDown(evt){
    AlignmentLastX = evt.clientX;
    AlignmentLastY = evt.clientY;
    AlignmentDragging = true;
    return false;
}

function AlignmentMouseMove(evt){
    if (AlignmentDragging){
        var x = evt.clientX;
        var y = evt.clientY;
        //alert(x-AlignmentLastX);
        var shift = (x-AlignmentLastX)/12;
        AlignmentStartPos -= shift;
        if (AlignmentStartPos < -1*region_analyse) AlignmentStartPos = -1*region_analyse;
        if (AlignmentStartPos > 1*region_analyse) AlignmentStartPos = 1*region_analyse;
        PlotAlignment(CurrentAlignment, locus);
        AlignmentLastX = x;
    }
    return false;
}

function AlignmentMouseMove_bulk(evt) {
    if (AlignmentDragging){
        var x = evt.clientX;
        var y = evt.clientY;
        var shift = (x-AlignmentLastX)/12;
        AlignmentStartPos -= shift;
        if (AlignmentStartPos < -region_analyse) AlignmentStartPos = -region_analyse;
        if (AlignmentStartPos > region_analyse+10) AlignmentStartPos = region_analyse+10;
        PlotAlignment_bulk(CurrentAlignment, locus, bulk_threshold);
        AlignmentLastX = x;
    }
    return false;
}

function AlignmentMouseMove_off(evt) {
    if (AlignmentDragging){
        var x = evt.clientX;
        var y = evt.clientY;
        var shift = (x-AlignmentLastX)/12;
        AlignmentStartPos -= shift;
        if (AlignmentStartPos < -region_analyse) AlignmentStartPos = -region_analyse;
        if (AlignmentStartPos > region_analyse+10) AlignmentStartPos = region_analyse+10;
        PlotAlignment_off(CurrentAlignment_off);
        AlignmentLastX = x;
    }
    return false;
}

function AlignmentMouseUp(evt) {
    AlignmentDragging = false;
    return false;
}

// Alignment algorithms
// modified version of Smith Watermann algorithm using adaptive aligning and dictionary based selector
// This program use some API from implementation by Prof Heng Li at https://github.com/lh3/bioseq-js
/**
 * Encode a sequence string with table
 * @param seq    sequence
 * @param table  encoding table; must be of size 256
 *
 * @return an integer array
 */

function Check_PolyN(seq){
    //TODO: for annotation
    // ONT data only!
    // check insertion or deletion close to polyN
}

function bsg_enc_seq(seq, table){
    if (table == null) return null;
    var s = [];
    s.length = seq.length;
    for (var i = 0; i < seq.length; ++i)
        s[i] = table[seq.charCodeAt(i)];
    return s;
}

/**
 * Generate scoring matrix from match/mismatch score
 *
 * @param n     size of the alphabet
 * @param a     match score, positive
 * @param b     mismatch score, negative
 *
 * @return square scoring matrix. The last row and column are zero, for
 * matching an ambiguous residue.
 */
function bsa_gen_score_matrix(n, a, b) {
    var m = [];
    if (b > 0) b = -b; // mismatch score b should be non-positive
    for (var i = 0; i < n - 1; ++i) {
        m[i] = [];
        for (var j = 0; j < n - 1; ++j)
            m[i][j] = i == j? a : b;
        m[i][j] = 0;
    }
    m[n-1] = [];
    for (var j = 0; j < n; ++j) m[n-1][j] = 0;
    return m;
}

/**
 * Generate query profile (a preprocessing step)
 *
 * @param _s      sequence in string or post bsg_enc_seq()
 * @param _m      score matrix or [match,mismatch] array
 * @param table   encoding table; must be consistent with _s and _m
 *
 * @return query profile. It is a two-dimensional integer matrix.
 */

function bsa_gen_query_profile(_s, _m, table) {
    var s = typeof _s == 'string'? bsg_enc_seq(_s, table) : _s;
    var qp = [], matrix;
    if (_m.length >= 2 && typeof _m[0] == 'number' && typeof _m[1] == 'number') { // match/mismatch score
        if (table == null) return null;
        var n = typeof table == 'number'? table : table[table.length-1] + 1;
        matrix = bsa_gen_score_matrix(n, _m[0], _m[1]);
    } else matrix = _m; // _m is already a matrix; FIXME: check if it is really a square matrix!
    for (var j = 0; j < matrix.length; ++j) {
        var qpj, mj = matrix[j];
        qpj = qp[j] = [];
        for (var i = 0; i < s.length; ++i)
            qpj[i] = mj[s[i]];
    }
    return qp;
}

/**
 * Local and global pairwise alignemnt
 * Global mode for RTT in PE, local for genaral purpose
    * @param target    target string
    * @param query     query string or query profile
    * @param matrix    square score matrix or [match,mismatch] array
    * @param gapsc     [gap_open,gap_ext] array; k-length gap costs gap_open+gap_ext*k
    * @param w         bandwidth, disabled by default
    * @return [score,target_start,cigar]. cigar is encoded in the BAM way, where
    * higher 28 bits keeps the length and lower 4 bits the operation in order of
    * "MIDNSH".
    */
function bsa_align(target, query, matrix, gapsc, is_local) {
	// convert bases to integers
	var t = bsg_enc_seq(target, bst_nt5);
	var qp = bsa_gen_query_profile(query, matrix, bst_nt5);
	var qlen = qp[0].length;

	// adjust band width
	var max_len = qlen > t.length? qlen : t.length;
    var w = true;
    var len_diff = t.target > qlen? t.target - qlen : qlen - t.target;
    w = w > len_diff? w : len_diff;
	
	// set gap score
	var gapo, gape; // these are penalties which should be non-negative
	if (typeof gapsc == 'number') gapo = 0, gape = gapsc > 0? gapsc : -gapsc;
	else gapo = gapsc[0] > 0? gapsc[0] : -gapsc[0], gape = gapsc[1] > 0? gapsc[1] : -gapsc[1];
	var gapoe = gapo + gape; // penalty for opening the first gap

	// initial values
	var NEG_INF = -0x40000000;
	var H = [], E = [], z = [], score, max = 0, end_i = -1, end_j = -1;
	if (is_local) {
		for (var j = 0; j <= qlen; ++j) H[j] = E[j] = 0;
	} else {
		H[0] = 0; E[0] = -gapoe - gapoe;
		for (var j = 1; j <= qlen; ++j) {
			if (j >= w) H[j] = E[j] = NEG_INF; // everything is -inf outside the band
			else H[j] = -(gapoe + gape * (j - 1)), E[j] = -(gapoe + gapoe + gape * j);
		}
	}

	// the DP loop
	for (var i = 0; i < t.length; ++i) {
		var h1 = 0, f = 0, m = 0, mj = -1;
		var zi, qpi = qp[t[i]];
		zi = z[i] = [];
		var beg = i > w? i - w : 0;
		var end = i + w + 1 < qlen? i + w + 1 : qlen; // only loop through [beg,end) of the query sequence
		if (!is_local) {
			h1 = beg > 0? NEG_INF : -(gapoe + gape * i);
			f  = beg > 0? NEG_INF : -(gapoe + gapoe + gape * i);
		}
		for (var j = beg; j < end; ++j) {
			// At the beginning of the loop: h=H[j]=H(i-1,j-1), e=E[j]=E(i,j), f=F(i,j) and h1=H(i,j-1)
			// If we only want to compute the max score, delete all lines involving direction "d".
			var e = E[j], h = H[j], d;
			H[j] = h1;           // set H(i,j-1) for the next row
			h += qpi[j];         // h = H(i-1,j-1) + S(i,j)
			d = h >= e? 0 : 1;
			h = h >= e? h : e;
			d = h >= f? d : 2;
			h = h >= f? h : f;    // h = H(i,j) = max{H(i-1,j-1)+S(i,j), E(i,j), F(i,j)}
			d = !is_local || h > 0? d : 1<<6;
			h1 = h;              // save H(i,j) to h1 for the next column
			mj = m > h? mj : j;
			m = m > h? m : h;    // update the max score in this row
			h -= gapoe;
			h = !is_local || h > 0? h : 0;
			e -= gape;
			d |= e > h? 1<<2 : 0;
			e = e > h? e : h;    // e = E(i+1,j)
			E[j] = e;            // save E(i+1,j) for the next row
			f -= gape;
			d |= f > h? 2<<4 : 0;
			f = f > h? f : h;    // f = F(i,j+1)
			zi[j] = d;           // z[i,j] keeps h for the current cell and e/f for the next cell
		}
		H[end] = h1, E[end] = is_local? 0 : NEG_INF;
		if (m > max) max = m, end_i = i, end_j = mj;
	}
	if (is_local && max == 0) return null;
	score = is_local? max : H[qlen];

	// backtrack to recover the alignment/cigar
	function push_cigar(ci, op, len) {
		if (ci.length == 0 || op != (ci[ci.length-1]&0xf))
			ci.push(len<<4|op);
		else ci[ci.length-1] += len<<4;
	}
	var cigar = [], tmp, which = 0, i, k, start_i = 0;
	if (is_local) {
		i = end_i, k = end_j;
		if (end_j != qlen - 1) // then add soft cliping
			push_cigar(cigar, 4, qlen - 1 - end_j);
	} else i = t.length - 1, k = (i + w + 1 < qlen? i + w + 1 : qlen) - 1; // (i,k) points to the last cell
	while (i >= 0 && k >= 0) {
		tmp = z[i][k - (i > w? i - w : 0)];
		which = tmp >> (which << 1) & 3;
		if (which == 0 && tmp>>6) break;
		if (which == 0) which = tmp & 3;
		if (which == 0)      { push_cigar(cigar, 0, 1); --i, --k; } // match
		else if (which == 1) { push_cigar(cigar, 2, 1); --i; } // deletion
		else                 { push_cigar(cigar, 1, 1), --k; } // insertion
	}
	if (is_local) {
		if (k >= 0) push_cigar(cigar, 4, k + 1); // add soft clipping
		start_i = i + 1;
	} else { // add the first insertion or deletion
		if (i >= 0) push_cigar(cigar, 2, i + 1);
		if (k >= 0) push_cigar(cigar, 1, k + 1);
	}
	for (var i = 0; i < cigar.length>>1; ++i) // reverse CIGAR
		tmp = cigar[i], cigar[i] = cigar[cigar.length-1-i], cigar[cigar.length-1-i] = tmp;
	return [score, start_i, cigar];
}

function bsa_cigar2gaps(target, query, start, cigar){
	var oq = '', ot = '', mid = '', lq = 0, lt = start;
	for (var k = 0; k < cigar.length; ++k) {
		var op = cigar[k]&0xf, len = cigar[k]>>4;
		if (op == 0) { // match
			oq += query.substr(lq, len);
			ot += target.substr(lt, len);
			lq += len, lt += len;
		} else if (op == 1) { // insertion
			oq += query.substr(lq, len);
			ot += Array(len+1).join("-");
			lq += len;
		} else if (op == 2) { // deletion
			oq += Array(len+1).join("-");
			ot += target.substr(lt, len);
			lt += len;
		} else if (op == 4) { // soft clip
			lq += len;
		}
	}
	var ut = ot.toUpperCase();
	var uq = oq.toUpperCase();
	for (var k = 0; k < ut.length; ++k)
		mid += ut.charAt(k) == uq.charAt(k)? '|' : ' ';
	return [ot, oq, mid];
}

// generate cigar to gap in breakpoint windows, bkp11, bkp22 is offset interest region of ref wrt gap add-in ref 
function bsa_cigar2gaps_breakpoint(target, query, start, cigar, bkp1, bkp2){
    var oq = '', ot = '', oq1 = '', lq = 0, lt = start;
    var bkp11 = bkp1;
    var bkp22 = bkp2;
    var aln_type = 0;
    var gap_len = 0;
    for (var k = 0; k < cigar.length; ++k) {
        var op = cigar[k]&0xf, len = cigar[k]>>4;
        //var len1 = Math.floor(len/3)
        //update breakpoints only, no update aln_type
        // first check the alignment start point position
        if (start > bkp11){
            aln_type=0;
            continue;
        } 
        else if (lt + len <= bkp11){
            if (op == 0) { // match
                oq += query.substr(lq, len);
                ot += target.substr(lt, len);
                oq1 += Array(len).fill('\xa0').join('');
                lq += len, lt += len;
            } else if (op == 1) { // insertion (only update bkp11, 22 for insertion in reference sequence)
                oq1 += query.substr(lq, len);
                lq += len;
                bkp11 += len
                bkp22 += len
            } else if (op == 2) { // deletion
                oq += Array(len+1).join("-");
                ot += target.substr(lt, len);
                lt += len;
                oq1 += Array(len).fill('\xa0').join('');
            } else if (op == 4) { // soft clip
                lq += len;
            }
        }
        // update aln_type ONE time, otherwise assign 'ambigous read' 
        else if (bkp22 >= lt+len){
            if (op == 0) { // match ! ONLY UPDATE ONCE
                oq += query.substr(lq, len);
                ot += target.substr(lt, len);
                oq1 += Array(len).fill('\xa0').join('');
                lq += len, lt += len;
                if (aln_type == 0){
                    aln_type = 1;
                }
            } else if ((op == 1)||(op == 2)) { // Combine indels
                gap_len = len;
                if (op == 1) {
                    oq1 += query.substr(lq, len);
                    lq += len;
                }
                else if (op == 2){
                    ot += target.substr(lt, len);
                    oq1 += Array(len).fill('\xa0').join('');
                    oq += Array(len+1).join("-");
                    lt += len;
                } 
                
                if (len%3 == 0){
                    //check previous state
                    if ((aln_type==0)||(aln_type==1)){
                        aln_type =2;
                    }
                    else {
                        // if aln_type already indel so it 's ambigious
                        aln_type = 8  // ambigous
                    }     
                }
                else{
                    if ((aln_type==0)||(aln_type==1)){
                        aln_type =3;
                    }
                    else {
                        aln_type = 8  // ambigous
                    }
                }
            } 
            else if (op == 4) { // soft clip
                lq += len;
            }
        }
        else {   // bk point cover single windows
            if (op == 0) { // match
                oq += query.substr(lq, len);
                ot += target.substr(lt, len);
                oq1 += Array(len).fill('\xa0').join('');
                lq += len, lt += len;
                if (aln_type==0){
                    aln_type = 1 //no indel
                }
            } else if ((op == 1)||(op == 2)) { // indel
                if (op == 1) {
                    oq1 += query.substr(lq, len);
                }
                else if (op == 2){
                    ot += target.substr(lt, len);
                    oq1 += Array(len).fill('\xa0').join('');
                    oq += Array(len+1).join("-");
                }  
                lq += len;
                if (len%3 == 0){
                    if (aln_type==0){
                        aln_type =2;
                        }
                } else{
                    if (aln_type==0){
                        aln_type =3;
                    }
                }
            } 
            else if (op == 4) { // soft clip
                lq += len;
            }
        }    
    }
    return [[oq.substr(bkp1-start, bkp2-bkp1), oq1.substr(bkp1-start, bkp2-bkp1)], aln_type, gap_len];
}

function TabClicked(i)
{
    if (i==0) document.getElementById("setup").style.display = "";
    else document.getElementById("setup").style.display = "none";
    if (i==1||i ==7||i ==8) document.getElementById("results").style.display = "";
    else document.getElementById("results").style.display = "none";

    if (i==2) document.getElementById("manual").style.display = "";
    else document.getElementById("manual").style.display = "none";

    if (i==3) document.getElementById("about").style.display = "";
    else document.getElementById("about").style.display = "none";

    if (i==4) document.getElementById("bulkview_result").style.display = "";
    else document.getElementById("bulkview_result").style.display = "none";

    if (i==5) document.getElementById("offtarget_view").style.display = "";
    else document.getElementById("offtarget_view").style.display = "none";
    if (i==6) document.getElementById("testdata").style.display = "";
    else document.getElementById("testdata").style.display = "none";
    if (i==1||i==7) document.getElementById("SVGpie").style.display = "";
    else document.getElementById("SVGpie").style.display = "none";
    if (i==8) document.getElementById("SVGpie_rima").style.display = "";
    else document.getElementById("SVGpie_rima").style.display = "none";
    if (i==9) document.getElementById("Utility").style.display = "";
    else document.getElementById("Utility").style.display = "none";
    if (i==10) document.getElementById("version").style.display = "";
    else document.getElementById("version").style.display = "none";

    document.getElementById("progress").style.display = "none";
    document.getElementById("progress1").style.display = "none";

    currenttab = i;
}

//reverse comp function
var ks_comp = {'A':'T','C':'G','G':'C','T':'A','M':'K','K':'M','Y':'R','R':'Y','V':'B','B':'V','H':'D','D':'H',
			   'a':'t','c':'g','g':'c','t':'a','m':'k','k':'m','y':'r','r':'y','v':'b','b':'v','h':'d','d':'h'};

function ReverseComplement(s)
{
	var i, t = '';
	for (i = 0; i < s.length; ++i) {
		var c = s.charAt(s.length - 1 - i);
		var d = ks_comp[c];
		t += d? d : c;
	}
	return t;
}

function getFastaSequence() {
    var myFastaURL;
    if (document.URL.includes('www')){
        myFastaURL = "https://www.crisprnano.de/gene_fasta/"+getSeq("GeneName")+".fa";
    }
    else {
        myFastaURL = "https://crisprnano.de/gene_fasta/"+getSeq("GeneName")+".fa";
    }
    fetch(myFastaURL)
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.text();
    })
    .then(data => {
        var lines = data.split('\n');
        var locus1 = lines.slice(1).join('');
        locus=locus1;
    })
    .catch(error => {
    if (error.message === 'Network response was not ok') {
        alert('The provided URL is not valid or the gene name is not found. Please check your input and try again. Or you can use the customized reference in Optional form below');
        locus="";
    } 
    else {
        alert('An unexpected error occurred: ' + error.message);
        locus="";
    }
    });
}
function getFastaSequence_list() {
    locus_list =[]
    if (document.URL.includes('www')){
        prefix_url = "https://www.crisprnano.de/gene_fasta/";
    }
    else {
        prefix_url = "https://crisprnano.de/gene_fasta/";
    }

    "https://www.crisprnano.de/gene_fasta/"
    gene_list = document.getElementsByName("GeneName_list")[0].value.split(',')
    // for (let  gene_name1 of gene_list){
    for (let i = 0; i< gene_list.length; i++){
        var gene_name1 = gene_list[i].trim()
        var myFastaURL = prefix_url+gene_name1.toUpperCase()+".fa";
        fetch(myFastaURL)
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.text();
        })
        .then(data => {
            var lines = data.split('\n');
            var locus1 = lines.slice(1).join('');
            locus_list[i]=locus1;
        })
        .catch(error => {
        if (error.message === 'Network response was not ok') {
            alert('The provided URL is not valid or the gene name is not found. Please check your input and try again.');
            locus_list =[];
        } 
        else {
            alert('An unexpected error occurred: ' + error.message);
            locus_list =[];
        }
    });
    }
    if (locus_list!=[]){
        alert('Loading given genes list successfully');
    }
}

function FileReceived() {
    var original = RestFromLastChunk+reader.result;
    var cursor = 0, origlen = original.length;
    // alignment parameter for affine score DP algorithms 
    var ms = 1 // match score
    var mms = -1//mismatch score
    var gapo = -4  // gap open score
    var gape = -1  // gap extent score
    var id = CurrentFileId;
    targetingOligo1 = getSeq("TargetingOligo"); //TargetingOligo
    PhredThreshold = 1*document.getElementsByName("Phred")[0].value;
    var prime_mode = document.getElementById('prime_editing').checked;
    var ML_mode = document.getElementById('run_mode').checked;
    var ML_genotype= 1*document.getElementsByName("ML_genotype")[0].value;

    //check target oligo in reference or reverse ref
    //check target oligo in reference or reverse ref
    if (targetingOligo1 !=""){
            var score_oligo_ref_fw = bsa_align(locus.substring(BreakPoint-region_analyse*1, BreakPoint + region_analyse*1), targetingOligo1, [ms, mms], [gapo, gape], is_local=true); 
            var score_oligo_ref_rv = bsa_align(locus.substring(BreakPoint-region_analyse*1, BreakPoint + region_analyse*1), ReverseComplement(targetingOligo1), [ms, mms], [gapo, gape], is_local=true);
            var oligo_index = score_oligo_ref_fw[0]>=score_oligo_ref_rv[0] ? score_oligo_ref_fw[1] : score_oligo_ref_rv[1]
            targetingOligo1 = score_oligo_ref_fw[0]>=score_oligo_ref_rv[0] ? targetingOligo1: ReverseComplement(targetingOligo1)
        }
    while (true) {
        var cursor1 = cursor;
        while (++cursor1<origlen && original[cursor1] != "\n");
        var cursor2 = cursor1+1;
        while (++cursor2<origlen && original[cursor2] != "\n");
        var cursor3 = cursor2+1;
        while (++cursor3<origlen && original[cursor3] != "\n");
        var cursor4 = cursor3+1;
        while (++cursor4<origlen && original[cursor4] != "\n");

        if (cursor4 >= origlen) break;
        else cursor = cursor4+1;

        var read = original.slice(cursor1+1,cursor2); 
        var phred = original.slice(cursor3+1,cursor4); 
        var readlen = read.length;
        var aln_type;

        var mean_phred = 0;
        for (let pos = 0; pos < readlen; pos++) {
            mean_phred = mean_phred + phred.charCodeAt(pos)-33;
        }
        mean_phred = (mean_phred/readlen).toFixed(1);
        if (phred_array[id].hasOwnProperty(mean_phred)){
            phred_array[id][mean_phred]+=1
        }
        else {
            phred_array[id][mean_phred] = 1
        }

        if (readlen >10) {
            if (length_array[id].hasOwnProperty(readlen)){
                length_array[id][readlen]+=1
            }
            else {
                length_array[id][readlen] = 1
            }
        }
        var gcContent_1 = calculateGCContent(read).toFixed(1)
        if (gcContent[id].hasOwnProperty(gcContent_1)){
            gcContent[id][gcContent_1]+=1
        }
        else {
            gcContent[id][gcContent_1] = 1
        }
        var index_oli_read = -1;
        var index_oli_read1 = -1;
        if (targetingOligo1 !=""){
                index_oli_read = read.search(targetingOligo1);
                index_oli_read1 = ReverseComplement(read).search(targetingOligo1);
            }

        if ((mean_phred > PhredThreshold)&&(CurrentFileChunk<2)){ 

            if (read.includes(locus_check1)||ReverseComplement(read).includes(locus_check1)||read.includes(locus_check2)||ReverseComplement(read).includes(locus_check2)){// UPDATE v2.0 checking 4 posiblities of read, threshold score =region_analyse+10 
                    var rst = bsa_align(locus, read, [ms, mms], [gapo, gape], is_local=true);
                    if (rst[0] < (region_analyse/2)){
                        try{
                        read = ReverseComplement(read);
                        rst = bsa_align(locus, read, [ms, mms], [gapo, gape], is_local=true);
                        }
                        catch (error){}
                    }
                    var str1 = ''
                    var fmt1 = bsa_cigar2gaps_breakpoint(locus, read, rst[1], rst[2], BreakPoint-region_analyse*1, BreakPoint + region_analyse*1);
                    var fmt = fmt1[0]
                    aln_type = fmt1[1]
                    if (index_oli_read != -1|| index_oli_read1 != -1){
                        aln_type = 7;
                    }

                    str1 += fmt[0] + '\n';
                    str1 += fmt[1] + '\n';

                    // new aln_type for desired edit and partial edit
                    if ((p_edit)||(d_edit)){
                        if (d_edit&&(read.includes(d_edit)||read.includes(ReverseComplement(d_edit)))){
                            if (fmt[1].trim()==""){
                                aln_type = 9;
                            }
                        }
                        else if (p_edit&&(read.includes(p_edit)||read.includes(ReverseComplement(p_edit)))){
                            if (fmt[1].trim()==""){
                                aln_type = 10;
                            }
                        }
                    }

                    if (aln_type !=0){
                        if (aln_dict[id].hasOwnProperty(str1)){
                            aln_dict[id][str1][0]+=1
                        }
                        else {
                            aln_dict[id][str1] = Array(2)
                            aln_dict[id][str1][0] = 1
                            aln_dict[id][str1][1] = aln_type
                        }
                    }
                }           
            
        }
        
        else if (ML_mode &&(mean_phred > PhredThreshold)){
            if (CurrentFileChunk==2){
                aln_dict_ML[CurrentFileId] = []
                let entries = Object.entries(aln_dict[CurrentFileId]);
                entries.sort((a, b) => b[1][0] - a[1][0]);
                let top10Dict = Object.fromEntries(entries.slice(0, ML_genotype));
                for (let key in top10Dict){
                    aln_dict_ML[CurrentFileId][KeytoSeq(key)[0]] = KeytoSeq(key)[1]
                }
            }
            else {
                for (let key in aln_dict_ML[CurrentFileId]){
                    if (read.includes(key)||read.includes(ReverseComplement(key))){
                        let key1 = aln_dict_ML[CurrentFileId][key]
                        aln_dict[CurrentFileId][key1][0]+=1;
                    }
                } 
            } 
        }
        else if (mean_phred > PhredThreshold){           
            if (targetingOligo1 !=""){
                var index_oli_read = read.search(targetingOligo1);
                if (index_oli_read!=-1){
                    aln_type = 7;
                    // remove this part in knockin, speed up the program
                    var str1 = ''
                    str1 += read.substring(index_oli_read- oligo_index, index_oli_read- oligo_index + region_analyse*2)+ '\n'+ '\n';
                    if (aln_dict[id].hasOwnProperty(str1)){
                        aln_dict[id][str1][0]+=1
                    }
                    else {
                        aln_dict[id][str1] = Array(2)
                        aln_dict[id][str1][0] = 1
                        aln_dict[id][str1][1] = aln_type
                    }
                }
                else {
                    index_oli_read = ReverseComplement(read).search(targetingOligo1);
                    if (index_oli_read!=-1){
                        read = ReverseComplement(read)
                        aln_type = 7;
                    // remove this part in knockin, speed up the program
                        var str1 = ''
                        str1 += read.substring(index_oli_read- oligo_index, index_oli_read- oligo_index + region_analyse*2)+ '\n'+ '\n';
                        if (aln_dict[id].hasOwnProperty(str1)){
                            aln_dict[id][str1][0]+=1
                        }
                        else {
                            aln_dict[id][str1] = Array(2)
                            aln_dict[id][str1][0] = 1
                            aln_dict[id][str1][1] = aln_type
                        }
                    }

                    //Check WT manually, speed up
                    else if (read.includes(locus.substring(BreakPoint-region_analyse*1, BreakPoint + region_analyse*1))){
                        aln_type = 1;
                    // remove this part in knockin, speed up the program
                        var str1 = ''
                        str1 += locus.substring(BreakPoint-region_analyse*1, BreakPoint + region_analyse*1)+ '\n'+ '\n';
                        if (aln_dict[id].hasOwnProperty(str1)){
                            aln_dict[id][str1][0]+=1
                        }
                        else {
                            aln_dict[id][str1] = Array(2)
                            aln_dict[id][str1][0] = 1
                            aln_dict[id][str1][1] = aln_type
                        }
                    }
                    else if (read.includes(ReverseComplement(locus.substring(BreakPoint-region_analyse*1, BreakPoint + region_analyse*1)))){
                        aln_type = 1;
                        var str1 = ''
                        str1 += locus.substring(BreakPoint-region_analyse*1, BreakPoint + region_analyse*1)+ '\n'+ '\n';
                        if (aln_dict[id].hasOwnProperty(str1)){
                            aln_dict[id][str1][0]+=1
                        }
                        else {
                            aln_dict[id][str1] = Array(2)
                            aln_dict[id][str1][0] = 1
                            aln_dict[id][str1][1] = aln_type
                        }
                    }
                    
                    else if (!prime_mode){
                        if (read.includes(locus_check1)||ReverseComplement(read).includes(locus_check1)||read.includes(locus_check2)||ReverseComplement(read).includes(locus_check2)){// UPDATE v2.0 checking 4 posiblities of read, threshold score =region_analyse+10 
                            var rst = bsa_align(locus, read, [ms, mms], [gapo, gape], is_local=true);
                            if (rst[0] < (region_analyse/2)){
                                try{
                                read = ReverseComplement(read);
                                rst = bsa_align(locus, read, [ms, mms], [gapo, gape], is_local=true);
                                }
                                catch (error){}
                            }
                            var str1 = ''
                            var fmt1 = bsa_cigar2gaps_breakpoint(locus, read, rst[1], rst[2], BreakPoint-region_analyse*1, BreakPoint + region_analyse*1);
                            var fmt = fmt1[0]
                            aln_type = fmt1[1]
                            // var str2_arr = fmt[0].split('-')
                            str1 += fmt[0] + '\n';
                            str1 += fmt[1] + '\n';
                            //aggregate aln track into dictionary
                            // if (containsAny(locus, str2_arr)||containsAny(ReverseComplement(locus), str2_arr)){
                            if (aln_type !=0){
                                if (aln_dict[id].hasOwnProperty(str1)){
                                    aln_dict[id][str1][0]+=1
                                }
                                else {
                                    aln_dict[id][str1] = Array(2)
                                    aln_dict[id][str1][0] = 1
                                    aln_dict[id][str1][1] = aln_type
                                }
                            }
                        }           
                    }
                }
            } 
            else {
                if (read.includes(locus_check1)||ReverseComplement(read).includes(locus_check1)||read.includes(locus_check2)||ReverseComplement(read).includes(locus_check2)){// UPDATE v2.0 checking 4 posiblities of read, threshold score =region_analyse+10 
                    var rst = bsa_align(locus, read, [ms, mms], [gapo, gape], is_local=true);
                    if (rst[0] < (region_analyse/2)){
                        try{
                        read = ReverseComplement(read);
                        rst = bsa_align(locus, read, [ms, mms], [gapo, gape], is_local=true);
                        }
                        catch (error){}
                    }
                    var str1 = ''
                    var fmt1 = bsa_cigar2gaps_breakpoint(locus, read, rst[1], rst[2], BreakPoint-region_analyse*1, BreakPoint + region_analyse*1);
                    var fmt = fmt1[0]
                    aln_type = fmt1[1]
                    // var str2_arr = fmt[0].split('-')
                    str1 += fmt[0] + '\n';
                    str1 += fmt[1] + '\n';
                    //aggregate aln track into dictionary
                    // if (containsAny(locus, str2_arr)||containsAny(ReverseComplement(locus), str2_arr)){
                    if (aln_type !=0){
                        if (aln_dict[id].hasOwnProperty(str1)){
                            aln_dict[id][str1][0]+=1
                        }
                        else {
                            aln_dict[id][str1] = Array(2)
                            aln_dict[id][str1][0] = 1
                            aln_dict[id][str1][1] = aln_type
                        }
                    }
                }           
            }
        }
        }
    RestFromLastChunk = original.substr(cursor);
    reader.result = "";
    reader = "";
    CurrentFileChunk++;

    if ((CurrentFileChunk)*chunksize >= files[CurrentFileId].size) {
            Pre_PlotAlignment(id, locus)
            PlotAlignment(id, locus)
            CurrentFileId++;
            CurrentFileChunk = 0;
            RestFromLastChunk = "";
        }

    if (CurrentFileId < files.length && CurrentFileId<96) {
        setTimeout("ReadNextFileChunk();",10);
    } else {
        DrawPie();
        DrawPie_rima();
    }
    }

function FileReceived_off() {
    var original = RestFromLastChunk+reader.result;
    var cursor = 0, origlen = original.length;
    // alignment parameter for affine score DP algorithms 
    var ms = 1 // match score
    var mms = -1 //mismatch score
    var gapo = -4  // gap open score
    var gape = -1  // gap extent score
    // var id = CurrentFileId;
    while (true) {
        var cursor1 = cursor;
        while (++cursor1<origlen && original[cursor1] != "\n");
        var cursor2 = cursor1+1;
        while (++cursor2<origlen && original[cursor2] != "\n");
        var cursor3 = cursor2+1;
        while (++cursor3<origlen && original[cursor3] != "\n");
        var cursor4 = cursor3+1;
        while (++cursor4<origlen && original[cursor4] != "\n");
        if (cursor4 >= origlen) break;
        else cursor = cursor4+1;

        var read = original.slice(cursor1+1,cursor2); 
        var phred = original.slice(cursor3+1,cursor4); 
        var readlen = read.length;
        var aln_type;
        var mean_phred = 0;
        for (let pos = 0; pos < readlen; pos++) {
            mean_phred = mean_phred + phred.charCodeAt(pos);
        }
        mean_phred = mean_phred/readlen;

        var max_off_score = -10000;
        var str1 = Array(4)
        var aln_type = Array(4)
        var max_index = 0

        if (mean_phred > PhredThreshold){
            for (let i=0; i< locus_list.length; i++){
                var target = locus_list[i];
                if (read.includes(locus_check1_off[i])||ReverseComplement(read).includes(locus_check1_off[i])||read.includes(locus_check2_off[i])||ReverseComplement(read).includes(locus_check2_off[i])){// UPDATE v2.0 checking 4 posiblities of read, threshold score =region_analyse+10 
                    var rst = bsa_align(target, read, [ms, mms], [gapo, gape], is_local=true);
                    if (rst[0] < (region_analyse*1+10)){
                        try{
                            read = ReverseComplement(read);
                            rst = bsa_align(target, read, [ms, mms], [gapo, gape], is_local=true);
                        }
                        catch (error){}
                        }
                    if (rst[0]>max_off_score){
                        max_off_score = rst[0];
                        max_index = i;
                    }
                    str1[i] = ''
                    var fmt1 = bsa_cigar2gaps_breakpoint(target, read, rst[1], rst[2], BreakPoint_off[i]-region_analyse*1, BreakPoint_off[i] + region_analyse*1);
                    var fmt = fmt1[0]
                    aln_type[i] = fmt1[1];
                    str1[i] += fmt[0] + '\n';
                    str1[i] += fmt[1] + '\n';
                }        
            }
            if (aln_type[max_index]!=0){
                if (aln_dict_off[max_index].hasOwnProperty(str1[max_index])){
                    aln_dict_off[max_index][str1[max_index]][0]+=1;
                }
                else {
                    aln_dict_off[max_index][str1[max_index]] = Array(2);
                    aln_dict_off[max_index][str1[max_index]][0] = 1;
                    aln_dict_off[max_index][str1[max_index]][1] = aln_type[max_index];
                }
            }         
        } 
    }
    RestFromLastChunk = original.substr(cursor);
    reader.result = "";
    reader = "";
    CurrentFileChunk++;

    if ((CurrentFileChunk)*chunksize >= files[CurrentFileId_off].size) {
        for (let i=0; i< locus_list.length; i++){
            Pre_PlotAlignment_off(i)
            PlotAlignment_off(i)
        }
        DrawPie_off();
    }
    else{
        setTimeout("ReadNextFileChunk_off();",10);
    }

}

function ReadNextFileChunk() {
    reader = new FileReader();
    reader.onload = FileReceived;
    reader.readAsText(files[CurrentFileId].slice(CurrentFileChunk*chunksize, (CurrentFileChunk+1)*chunksize));
    document.getElementById('progress').innerHTML = "File "+(CurrentFileId+1)+": "+ (CurrentFileChunk*chunksize/1000000).toFixed(2)+ " MB / "+Math.round(files[CurrentFileId].size/1000000)+" MB processed. Please keep this window open and don't switch to other tabs in your web browser!";
}

function ReadNextFileChunk_off(){
    reader = new FileReader();
    reader.onload = FileReceived_off;
    reader.readAsText(files[CurrentFileId_off].slice(CurrentFileChunk*chunksize, (CurrentFileChunk+1)*chunksize));
    document.getElementById('progress1').innerHTML = "OFFTARGET Analysing.\n Current file "+(CurrentFileId_off+1)+" : "+ (CurrentFileChunk*chunksize/1000000).toFixed(2)+ " MB / "+Math.round(files[CurrentFileId_off].size/1000000)+" MB processed. Please keep this window open and don't switch to other tabs in your web browser!!";
}

const NS = "http://www.w3.org/2000/svg";
const TAU = 2 * Math.PI;

function el(tag, attrs = {}, text = "") {
  const n = document.createElementNS(NS, tag);
  for (const k in attrs) n.setAttribute(k, attrs[k]);
  if (text) n.textContent = text;
  return n;
}

function arc(svgEl, cx, cy, r, last, angle, fill) {
  const sx = r * Math.cos(last), sy = r * Math.sin(last);
  const dx = r * Math.cos(angle) - sx, dy = r * Math.sin(angle) - sy;
  const large = (angle - last > Math.PI) ? 1 : 0;
  svgEl.appendChild(
    el("path", {
      d: `M ${cx},${cy} l ${sx},${sy} a ${r} ${r} 0 ${large} 1 ${dx} ${dy} z`,
      fill,
      "pointer-events": "none"
    })
  );
}

function addSlice(svgEl, angle, value, denom, fill, cx, cy, r) {
  const last = angle;
  angle += TAU * 0.995 * (value / denom || 0);
  arc(svgEl, cx, cy, r, last, angle, fill);
  return angle;
}

function DrawPie(active_barcode = 0) {
  const svg = document.getElementById("SVGpie");
  TabClicked(1);

  // reset svg and listener (same behavior as original)
  while (svg.lastChild) svg.removeChild(svg.lastChild);
  svg.addEventListener("mousedown", PieClick, false);

  const ROT  = ["rgb(255,69,0)","rgb(255,127,80)","rgb(255,215,0)","rgb(255,69,0)","rgb(255,127,80)","rgb(255,215,0)"];
  const BLAU = ["rgb(72,118,255)","rgb(99,184,255)","rgb(135,206,250)","rgb(72,118,255)","rgb(99,184,255)","rgb(135,206,250)"];

  // --- compute maximum summary for scale (same as original) ---
  let maxsum = 0;
  for (let b = 0; b < 96; b++) {
    if (summary_track[b][7] > maxsum) maxsum = summary_track[b][7];
  }

  // --- draw 96 small pies (same layout & order as original) ---
  for (let barcode = 0; barcode < 96; barcode++) {
    let sum = 0;
    const inf_indel1 = Array(6).fill(0);
    const out_indel1 = Array(6).fill(0);
    let p_edit1 = 0, d_edit1 = 0;

    // classify indels (uses aln_dict_fil and per-barcode values like original)
    for (let key in aln_dict_fil[barcode]) {
      const t = aln_dict[barcode][key][1];
      const cnt = aln_dict_fil[barcode][key];
      if (t === 2) {
        for (let i = 0; i < 6; i++) if (!inf_indel1[i]) { inf_indel1[i] = cnt; sum += cnt; break; }
      } else if (t === 3) {
        for (let i = 0; i < 6; i++) if (!out_indel1[i]) { out_indel1[i] = cnt; sum += cnt; break; }
      } else if (t === 9) {
        d_edit1 += cnt; sum += cnt;
      } else if (t === 10) {
        p_edit1 += cnt; sum += cnt;
      }
    }

    sum += summary_track[barcode][2] + summary_track[barcode][1];

    // same size/position calculation as original
    const size = 24 * Math.sqrt(sum / maxsum || 0);
    const midx = (barcode % 12) * 50 + 25;
    const midy = Math.floor(barcode / 12) * 65 + 25;

    if (summary_track[barcode][7] > 0) {
      let angle = -Math.PI / 2;

      // wt
      angle = addSlice(svg, angle, summary_track[barcode][2], sum, "rgb(200,200,200)", midx, midy, size);

      // in-frame indels (6 slots)
      for (let i = 0; i < 6; i++) angle = addSlice(svg, angle, inf_indel1[i], sum, BLAU[i], midx, midy, size);

      // out-of-frame indels (6 slots)
      for (let i = 0; i < 6; i++) angle = addSlice(svg, angle, out_indel1[i], sum, ROT[i], midx, midy, size);

      // desired & partial (only drawn if global p_edit/d_edit set — same logic as original)
      if (p_edit !== "" || d_edit !== "") {
        angle = addSlice(svg, angle, summary_track[barcode][6], sum, "rgb(156, 39, 176)", midx, midy, size);
        angle = addSlice(svg, angle, summary_track[barcode][8], sum, "rgb(198, 255, 0)", midx, midy, size);
      }

      // targeting oligo
      addSlice(svg, angle, summary_track[barcode][1], sum, "rgb(0,232,30)", midx, midy, size);
    }

    // center text (highlight active barcode just like original)
    const t = el("text", {
      "font-family": "sans-serif", "font-weight": "100",
      x: midx, y: midy + 36, "font-size": "11", "text-anchor": "middle", "pointer-events": "none"
    });
    if (active_barcode === barcode) t.setAttribute("fill", "rgb(16, 126, 204)");

    if (!genotype[barcode]) t.textContent = GetWellPos(barcode);
    else t.textContent = `${GetWellPos(barcode)} (${genotype[barcode]})`;
    svg.appendChild(t);
  }

  // --- legend (keeps exact coordinates & behaviour) ---
  let legendX = 13 * 50 + 25;
  let legendY = 0 * 65 + 25;
  for (let i = 0; i < 8; i++) {
    const vol = Math.floor(maxsum / 100) * 100 / Math.pow(2, i);
    const rsize = 24 * Math.sqrt(vol / maxsum || 0);
    svg.appendChild(el("circle", { cx: legendX, cy: legendY, r: rsize, fill: "none", stroke: "rgb(100,100,100)" }));
    svg.appendChild(el("text", { "font-family": "sans-serif", "font-weight": "100", x: legendX + 40, y: legendY + 3, "font-size": "12" }, Math.round(vol) + " reads"));
    legendY += rsize * 2 + 10;
  }

  // colored legend dots (same positions as original)
  for (let i = 0; i < 3; i++) {
    svg.appendChild(el("circle", { cx: legendX + 20 * i - 10, cy: legendY + 30 + 20, r: 6, fill: BLAU[i] }));
  }
  for (let i = 0; i < 3; i++) {
    svg.appendChild(el("circle", { cx: legendX + 20 * i - 10, cy: legendY + 30 + 40, r: 6, fill: ROT[i] }));
  }
  svg.appendChild(el("circle", { cx: legendX + 10, cy: legendY + 30 + 60, r: 6, fill: "rgb(200,200,200)" }));
  svg.appendChild(el("circle", { cx: legendX + 10, cy: legendY + 30 + 80, r: 6, fill: "rgb(0,200,0)" }));

  if (p_edit !== "" || d_edit !== "") {
    svg.appendChild(el("circle", { cx: legendX + 10, cy: legendY + 30 + 100, r: 6, fill: "rgb(156, 39, 176)" }));
    svg.appendChild(el("circle", { cx: legendX + 10, cy: legendY + 30 + 120, r: 6, fill: "rgb(198, 255, 0)" }));
  }

  // legend labels (exact same pos & text)
  svg.appendChild(el("text", { "font-family": "sans-serif", "font-weight": "100", x: legendX + 50, y: legendY + 53, "font-size": "12" }, "in-frame indels"));
  svg.appendChild(el("text", { "font-family": "sans-serif", "font-weight": "100", x: legendX + 50, y: legendY + 53 + 20, "font-size": "12" }, "out-of-frame indels"));
  svg.appendChild(el("text", { "font-family": "sans-serif", "font-weight": "100", x: legendX + 50, y: legendY + 53 + 40, "font-size": "12" }, "no indel"));
  svg.appendChild(el("text", { "font-family": "sans-serif", "font-weight": "100", x: legendX + 50, y: legendY + 53 + 60, "font-size": "12" }, "targeted mutagenesis"));

  if (p_edit !== "" || d_edit !== "") {
    svg.appendChild(el("text", { "font-family": "sans-serif", "font-weight": "100", x: legendX + 50, y: legendY + 53 + 80, "font-size": "12" }, "DESIRED edit"));
    svg.appendChild(el("text", { "font-family": "sans-serif", "font-weight": "100", x: legendX + 50, y: legendY + 53 + 100, "font-size": "12" }, "PARTIAL edit"));
  }

  document.title = "Result for " + document.getElementsByName("GeneName")[0].value + " (" + files_name.length + " barcodes read)";
}


function DrawPie_rima() {
  const svg = document.getElementById("SVGpie_rima");
  TabClicked(1);
  // reset svg
  while (svg.lastChild) svg.removeChild(svg.lastChild);
  // register mouse listener
  svg.addEventListener("mousedown", PieClick_rima, false);
  const BLAU = [
    "rgb(50,42,126)",
    "rgb(16,115,179)",
    "rgb(38,170,220)"
  ];
  const COLORS = [
    "rgb(84,199,199)", // MH-del
    BLAU[1],           // NHEJ
    "rgb(200,200,200)",// Other EJ
    "rgb(154,34,93)",  // HDR-KI
    BLAU[2]            // NHEJ-KI
  ];

  // find max sum for scaling
  let maxsum = 0;
  for (let b = 0; b < 96; b++) {
    if (summary_track[b][7] > maxsum) maxsum = summary_track[b][7];
  }

  for (let b = 0; b < 96; b++) {
    const midx = (b % 12) * 50 + 25;
    const midy = Math.floor(b / 12) * 65 + 25;
    if (summary_track[b][7] > 0) {
      const values = rima_hist_all[b];
      const sum = values.reduce((a, v) => a + v, 0);
      const size = 24 * Math.sqrt(sum / maxsum);
      let angle = -Math.PI / 2;
      values.forEach((v, i) => {
        angle = addSlice(svg, angle, v, sum, COLORS[i], midx, midy, size);
      });
    }

    // well position text
    svg.appendChild(
      el("text", {
        "font-family": "sans-serif",
        "font-weight": "100",
        x: midx,
        y: midy + 36,
        "font-size": "11",
        "text-anchor": "middle",
        "pointer-events": "none"
      }, GetWellPos(b))
    );
  }

  // legend (circles for size scaling)
  let midx = 13 * 50 + 25;
  let midy = 25;
  for (let i = 0; i < 8; i++) {
    const vol = Math.floor(maxsum / 100) * 100 / Math.pow(2, i);
    const size = 24 * Math.sqrt(vol / maxsum);
    svg.appendChild(el("circle", {
      cx: midx, cy: midy, r: size,
      fill: "none", stroke: "rgb(100,100,100)"
    }));
    svg.appendChild(el("text", {
      "font-family": "sans-serif",
      "font-weight": "100",
      x: midx + 40,
      y: midy + 3,
      "font-size": "12"
    }, `${Math.round(vol)} reads`));
    midy += size * 2 + 10;
  }
  // legend categories
  const LEGEND_LABELS = ["MH-del", "NHEJ", "NHEJ-KI", "HDR-KI", "Other EJ"];
  const LEGEND_COLORS = [
    "rgb(84,199,199)",
    BLAU[1],
    KI_1,
    KI_2,
    "rgb(200,200,200)"
  ];

  LEGEND_LABELS.forEach((label, i) => {
    svg.appendChild(el("circle", {
      cx: midx + 10,
      cy: midy + 50 + i * 20,
      r: 6,
      fill: LEGEND_COLORS[i]
    }));
    svg.appendChild(el("text", {
      "font-family": "sans-serif",
      "font-weight": "100",
      x: midx + 50,
      y: midy + 53 + i * 20,
      "font-size": "12"
    }, label));
  });

  document.title = `Result for ${document.getElementsByName("GeneName")[0].value} (${files_name.length} barcodes read)`;
}

function DrawPie_bulk() {
  const NS   = "http://www.w3.org/2000/svg";
  const svgBulk = document.getElementById("SVGpie_bulk");
  const svgRima = document.getElementById("RIMApie_bulk");
  const barcode = CurrentAlignment;
  const size = 75;
  let midx = 100, midy = 100;

  TabClicked(4);

  // --- helpers (no geometry changes) ---
  const clear = svg => { while (svg.lastChild) svg.removeChild(svg.lastChild); };
  const el = (tag, attrs = {}, text = "") => {
    const n = document.createElementNS(NS, tag);
    for (const [k, v] of Object.entries(attrs)) n.setAttribute(k, v);
    if (text) n.textContent = text;
    return n;
  };
  const arc = (svg, cx, cy, r, last, angle, fill) => {
    const sx = r * Math.cos(last),  sy = r * Math.sin(last);
    const dx = r * Math.cos(angle) - sx, dy = r * Math.sin(angle) - sy;
    const large = (angle - last > Math.PI) ? 1 : 0;
    svg.appendChild(el("path", {
      d: `M ${cx},${cy} l ${sx},${sy} a ${r} ${r} 0 ${large} 1 ${dx} ${dy} z`,
      fill, "pointer-events": "none"
    }));
  };
  const addSlice = (svg, angle, value, denom, fill) => {
    const last = angle;
    angle += TAU * 0.995 * (value / denom);
    arc(svg, midx, midy, size, last, angle, fill);
    return angle;
  };

  clear(svgBulk);
  clear(svgRima);

  // original color sets (6 slots each)
  const ROT  = ["rgb(255,69,0)","rgb(255,127,80)","rgb(255,215,0)",
                "rgb(255,69,0)","rgb(255,127,80)","rgb(255,215,0)"];
  const BLAU = ["rgb(72,118,255)","rgb(99,184,255)","rgb(135,206,250)",
                "rgb(72,118,255)","rgb(99,184,255)","rgb(135,206,250)"];

  // --- collect counts exactly as before (6 slots) ---
  let inf_indel1 = Array(6).fill(0);
  let out_indel1 = Array(6).fill(0);
  let sum = 0;

  for (let key in aln_dict_bulk) {
    const t = aln_dict[barcode][key][1];
    if (t === 2) {
      for (let i = 0; i < 6; i++) if (!inf_indel1[i]) { inf_indel1[i] = aln_dict_bulk[key]; sum += inf_indel1[i]; break; }
    } else if (t === 3) {
      for (let i = 0; i < 6; i++) if (!out_indel1[i]) { out_indel1[i] = aln_dict_bulk[key]; sum += out_indel1[i]; break; }
    }
  }

  const sum_bulk = Object.values(aln_dict_bulk).reduce((a, b) => a + b, 0);
  sum += summary_track[barcode][2] + summary_track[barcode][1];

  // --- bulk pie (same order & angles) ---
  if (summary_track[barcode][7] > 0) {
    let angle = -Math.PI / 2;

    // no indel (WT)
    angle = addSlice(svgBulk, angle, summary_track[barcode][2], sum, "rgb(200,200,200)");

    // in-frame indels (6 slots)
    for (let i = 0; i < 6; i++) angle = addSlice(svgBulk, angle, inf_indel1[i], sum, BLAU[i]);

    // out-of-frame indels (6 slots)
    for (let i = 0; i < 6; i++) angle = addSlice(svgBulk, angle, out_indel1[i], sum, ROT[i]);

    // desired & partial (only when edits supplied)
    if (p_edit !== "" || d_edit !== "") {
      angle = addSlice(svgBulk, angle, summary_track[barcode][6], sum, "rgb(156, 39, 176)");
      angle = addSlice(svgBulk, angle, summary_track[barcode][8], sum, "rgb(198, 255, 0)");
    }

    // targeting oligo
    addSlice(svgBulk, angle, summary_track[barcode][1], sum, "rgb(0,232,30)");
  }

  // --- center label ---
  svgBulk.appendChild(el("text", {
    "font-family":"sans-serif","font-weight":"100","x":midx,"y":midy+36,
    "font-size":"11","text-anchor":"middle","pointer-events":"none"
  }, GetWellPos(barcode)));

  // --- GENOTYPE RATIO header (same pos) ---
  svgBulk.appendChild(el("text", {
    "font-family":"sans-serif","font-weight":"100","x":10,"y":15,
    "font-size":"15","text-anchor":"left","pointer-events":"none"
  }, "GENOTYPE RATIO"));

  // --- legend circles (exact positions as original) ---
  midx = 25; midy = 195;

  for (let i = 0; i < 3; i++) {
    svgBulk.appendChild(el("circle", { cx: midx+20*i, cy: midy+40, r: 6, fill: BLAU[i] }));
  }
  for (let i = 0; i < 3; i++) {
    svgBulk.appendChild(el("circle", { cx: midx+20*i, cy: midy+60, r: 6, fill: ROT[i] }));
  }
  svgBulk.appendChild(el("circle", { cx: midx+20, cy: midy+80,  r:6, fill:"rgb(200,200,200)" }));
  svgBulk.appendChild(el("circle", { cx: midx+20, cy: midy+100, r:6, fill:"rgb(0,200,0)" }));

  if (p_edit !== "" || d_edit !== "") {
    svgBulk.appendChild(el("circle", { cx: midx+20, cy: midy+120, r:6, fill:"rgb(156, 39, 176)" }));
    svgBulk.appendChild(el("circle", { cx: midx+20, cy: midy+140, r:6, fill:"rgb(198, 255, 0)" }));
  }

  // --- summary texts (same positions & styles) ---
  svgBulk.appendChild(el("text", {
    x: midx+40, y: midy+5, "font-size":"14","font-weight":"600"
  }, `SUMMARY: Gene: ${document.getElementsByName("GeneName")[0].value}   |   File ${GetWellPos(barcode)}: ${files_name[barcode]}`));

  svgBulk.appendChild(el("text", { x:midx+79, y:midy+26, "font-size":"16" }, "Total aligned reads in bulk: "));
  svgBulk.appendChild(el("text", {
    x:midx+280, y:midy+26, "font-size":"16","font-weight":"600", fill:"rgb(255, 0, 0)"
  }, String(sum_bulk)));

  svgBulk.appendChild(el("text", {
    "font-family":"sans-serif","font-weight":"100", x:midx+80, y:midy+42, "font-size":"12"
  }, `in-frame indels: ${summary_track[barcode][3]} READS, (${summary_track_select[barcode+1][3]} %)`));

  svgBulk.appendChild(el("text", {
    "font-family":"sans-serif","font-weight":"100", x:midx+80, y:midy+62, "font-size":"12"
  }, "out-of-frame indels: "));

  svgBulk.appendChild(el("text", {
    "font-family":"sans-serif","font-weight":"600", fill:"rgb(255,0,0)", x:midx+190, y:midy+62, "font-size":"12"
  }, `${summary_track[barcode][4]} READS, (${summary_track_select[barcode+1][4]} %)`));

  svgBulk.appendChild(el("text", {
    "font-family":"sans-serif","font-weight":"100", x:midx+80, y:midy+82, "font-size":"12"
  }, `no indel: ${summary_track[barcode][2]} READS, (${summary_track_select[barcode+1][2]} %)`));

  svgBulk.appendChild(el("text", {
    "font-family":"sans-serif","font-weight":"100", x:midx+80, y:midy+102, "font-size":"12"
  }, `targeted mutagenesis (KI): ${summary_track[barcode][1]} READS, (${summary_track_select[barcode+1][1]} %)`));

  if (p_edit !== "" || d_edit !== "") {
    svgBulk.appendChild(el("text", {
      "font-family":"sans-serif","font-weight":"100", x:midx+80, y:midy+122, "font-size":"12"
    }, `DESIRED edit: ${(summary_track[barcode][6]*100/summary_track[barcode][7]).toFixed(2)}%`));

    svgBulk.appendChild(el("text", {
      "font-family":"sans-serif","font-weight":"100", x:midx+80, y:midy+142, "font-size":"12"
    }, `PARTIAL edit: ${(summary_track[barcode][8]*100/summary_track[barcode][7]).toFixed(2)}%`));
  }

  // ---------------- RIMA Pie (unchanged geometry) ----------------
  clear(svgRima);
  let angle = -Math.PI / 2, last = angle;
  midx = 100; midy = 100;
  const rimaSum = rima_hist_all[barcode][0]+rima_hist_all[barcode][1]+rima_hist_all[barcode][2]+rima_hist_all[barcode][3]+rima_hist_all[barcode][4];

  // MH-Del
  angle = addSlice(svgRima, angle, rima_hist_all[barcode][0], rimaSum, "rgb(84, 199, 199)");
  // NHEJ
  angle = addSlice(svgRima, angle, rima_hist_all[barcode][1], rimaSum, BLAU[1]);
  // Other EJ
  angle = addSlice(svgRima, angle, rima_hist_all[barcode][2], rimaSum, "rgb(200, 200, 200)");
  // NHEJ KI
  angle = addSlice(svgRima, angle, rima_hist_all[barcode][3], rimaSum, "rgb(154, 34, 93)");
  // HDR KI
  angle = addSlice(svgRima, angle, rima_hist_all[barcode][4], rimaSum, BLAU[2]);

  // RIMA title
  svgRima.appendChild(el("text", {
    "font-family":"sans-serif","font-weight":"100","x":10,"y":15,
    "font-size":"15","text-anchor":"left","pointer-events":"none"
  }, "RIMA RATIO"));

  // RIMA legend (same positions)
  midx = 25; midy = 195;
  svgRima.appendChild(el("circle", { cx: midx+20, cy: midy,    r:6, fill:"rgb(84, 199, 199)" }));
  svgRima.appendChild(el("circle", { cx: midx+20, cy: midy+20, r:6, fill:BLAU[1] }));
  svgRima.appendChild(el("circle", { cx: midx+20, cy: midy+40, r:6, fill:KI_1 }));
  svgRima.appendChild(el("circle", { cx: midx+20, cy: midy+60, r:6, fill:KI_2 }));
  svgRima.appendChild(el("circle", { cx: midx+20, cy: midy+80, r:6, fill:"rgb(200, 200, 200)" }));

  svgRima.appendChild(el("text", {"font-family":"sans-serif","font-weight":"100", x:midx+80, y:midy+2,  "font-size":"12"},
    `MH-del:    ${(100*rima_hist_all[barcode][0]/rimaSum).toFixed(2)} %`));
  svgRima.appendChild(el("text", {"font-family":"sans-serif","font-weight":"100", x:midx+80, y:midy+22, "font-size":"12"},
    `NHEJ:    ${(100*rima_hist_all[barcode][1]/rimaSum).toFixed(2)} %`));
  svgRima.appendChild(el("text", {"font-family":"sans-serif","font-weight":"100", x:midx+80, y:midy+42, "font-size":"12"},
    `NHEJ KI:    ${(100*rima_hist_all[barcode][3]/rimaSum).toFixed(2)} %`));
  svgRima.appendChild(el("text", {"font-family":"sans-serif","font-weight":"100", x:midx+80, y:midy+62, "font-size":"12"},
    `HDR KI:    ${(100*rima_hist_all[barcode][4]/rimaSum).toFixed(2)} %`));
  svgRima.appendChild(el("text", {"font-family":"sans-serif","font-weight":"100", x:midx+80, y:midy+82, "font-size":"12"},
    `Other EJ:    ${(100*rima_hist_all[barcode][2]/rimaSum).toFixed(2)} %`));

  // ---------------- QC plots (unchanged layout) ----------------
  {
    const qualityScores = phred_array[barcode];
    const x = Object.keys(qualityScores).map(k => parseInt(k));
    const y = Object.values(qualityScores);

    Plotly.newPlot('QC_plot', [{
      x, y, type:'bar',
      marker:{ color:'rgba(55, 128, 191, 0.7)', line:{ color:'rgba(55, 128, 191, 1.0)', width:2 } }
    }], {
      title:'Quality Score Histogram', xaxis:{ title:'Quality', range:[-10,60] }, yaxis:{ title:'Counts' }, dtick:5
    });
  }
  {
    const read_length = length_array[barcode];
    const x1 = Object.keys(read_length).map(k => parseInt(k));
    const y1 = Object.values(read_length);

    Plotly.newPlot('read_plot', [{
      x:x1, y:y1, type:'bar', width:2,
      marker:{ color:'rgba(55, 128, 191, 0.7)', line:{ color:'rgba(55, 128, 191, 1.0)', width:2 } }
    }], {
      title:'Read length (bp)', xaxis:{ title:'Read length (bp)', range:[10,2000] }, yaxis:{ title:'Counts' }
    });
  }
  {
    const gc = gcContent[barcode];
    const x2 = Object.keys(gc).map(k => parseInt(k));
    const y2 = Object.values(gc);

    Plotly.newPlot('GC_plot', [{
      x:x2, y:y2, type:'bar',
      marker:{ color:'rgba(55, 128, 191, 0.7)', line:{ color:'rgba(55, 128, 191, 1.0)', width:2 } }
    }], {
      title:'GC content', xaxis:{ title:'GC content %', range:[10,90] }, yaxis:{ title:'Counts' }
    });
  }

  document.title = `Bulk Result for ${document.getElementsByName("GeneName")[0].value} (${files_name.length} barcodes read)`;
}


function DrawPie_off()
{
    var svg = document.getElementById("SVGpie_off");
    var NS="http://www.w3.org/2000/svg";

    TabClicked(5);
    //reset svg:
    while (svg.lastChild) svg.removeChild(svg.lastChild);

    //register mouse listener:
    svg.addEventListener("mousedown", PieClick_off, false);

    var ROT= ["rgb(232,0,30)","rgb(255,102,0)","rgb(252,176,78)", "rgb(232,0,30)","rgb(255,102,0)","rgb(252,176,78)"]; 
    var BLAU=["rgb(50,42,126)","rgb(16,115,179)","rgb(38,170,220)", "rgb(50,42,126)","rgb(16,115,179)","rgb(38,170,220)"];

    var maxsum = 0;
    for (var barcode=0; barcode<4; barcode++) {
        if (summary_track_off[barcode][7] > maxsum) maxsum = summary_track_off[barcode][7];
    }
    
    for (var barcode=0; barcode<5; barcode++) {
        var sum = 0;
        var gene_i = barcode;
        var inf_indel1 = Array(6)
        var out_indel1 = Array(6)
        var oligo
        for (let i=0; i <6; i++){
            inf_indel1[i] = 0;
            out_indel1[i] = 0;
        }
        // classify indel into several subset
        for (let key in aln_dict_fil_off[barcode]){
            if (aln_dict_off[barcode][key][1] == 2){
                for (let i=0; i <6; i++){
                    if (inf_indel1[i]==0){
                        inf_indel1[i]=aln_dict_fil_off[barcode][key];
                        break;
                    }
                }
            } else if (aln_dict_off[barcode][key][1] == 3){
                for (let i=0; i <6; i++){
                    if (out_indel1[i]==0){
                        out_indel1[i]=aln_dict_fil_off[barcode][key];
                        break;
                    }
                }
            }
        }
        
        var size = 2*24*Math.sqrt(summary_track_off[barcode][7]/maxsum);
        var midx = (barcode%12)*180 + 300;
        var midy = Math.floor(barcode/12) * 65 + 100;

        if (summary_track_off[barcode][7] > 0) {
            //wt:
            var angle = -3.1415/2;
            var lastangle = angle;
            angle+=2*3.1415*0.995*summary_track_off[barcode][2]/summary_track_off[barcode][7];

            //SVG:
            var startx = size*Math.cos(lastangle);
            var starty = size*Math.sin(lastangle);
            var plusx = size*(Math.cos(angle)-Math.cos(lastangle));
            var plusy = size*(Math.sin(angle)-Math.sin(lastangle));
            var largearc = 0;
            if (angle-lastangle > 3.1415) largearc = 1;
            var SVGObj= document.createElementNS(NS,"path");
            SVGObj.setAttributeNS(null, "d", "M "+midx+","+midy+" l "+startx+","+starty+" a "+size+" "+size+" 0 "+largearc+" 1 "+plusx+" "+plusy+" z");
            SVGObj.style.fill="rgb(200,200,200)";

            SVGObj.setAttribute("pointer-events","none");
            svg.appendChild(SVGObj);
            for (let i=0; i <6; i++){
                // inframe indel1
                lastangle = angle;
                angle+=2*3.1415*0.995*inf_indel1[i]/summary_track_off[barcode][7];
                var startx = size*Math.cos(lastangle);
                var starty = size*Math.sin(lastangle);
                var plusx = size*(Math.cos(angle)-Math.cos(lastangle));
                var plusy = size*(Math.sin(angle)-Math.sin(lastangle));
                var largearc = 0;
                if (angle-lastangle > 3.1415) largearc = 1;
                var SVGObj= document.createElementNS(NS,"path");
                SVGObj.setAttributeNS(null, "d", "M "+midx+","+midy+" l "+startx+","+starty+" a "+size+" "+size+" 0 "+largearc+" 1 "+plusx+" "+plusy+" z");
                SVGObj.style.fill=BLAU[i];
                SVGObj.setAttribute("pointer-events","none");
                svg.appendChild(SVGObj);
            }

            for (let i=0; i <6; i++){
                // outframe indel
                lastangle = angle;
                angle+=2*3.1415*0.995*out_indel1[i]/summary_track_off[barcode][7];
                var startx = size*Math.cos(lastangle);
                var starty = size*Math.sin(lastangle);
                var plusx = size*(Math.cos(angle)-Math.cos(lastangle));
                var plusy = size*(Math.sin(angle)-Math.sin(lastangle));
                var largearc = 0;
                if (angle-lastangle > 3.1415) largearc = 1;
                var SVGObj= document.createElementNS(NS,"path");
                SVGObj.setAttributeNS(null, "d", "M "+midx+","+midy+" l "+startx+","+starty+" a "+size+" "+size+" 0 "+largearc+" 1 "+plusx+" "+plusy+" z");
                SVGObj.style.fill=ROT[i];
                SVGObj.setAttribute("pointer-events","none");
                svg.appendChild(SVGObj);
            }
        }

        //SVG:
        var SVGObj= document.createElementNS(NS,"text");
        SVGObj.setAttribute("font-family", "sans-serif");
        SVGObj.setAttribute("font-weight", "200");
        SVGObj.setAttribute("x", midx);
        SVGObj.setAttribute("y", midy+120);
        SVGObj.setAttribute("font-size", "14");
        SVGObj.setAttribute("text-anchor", "middle");
        SVGObj.setAttribute("font-weight", "600");
        SVGObj.setAttribute("pointer-events","none");
        SVGObj.textContent = gene_list[barcode];
        svg.appendChild(SVGObj);

        SVGObj= document.createElementNS(NS,"text");
        SVGObj.setAttribute("x", midx);
        SVGObj.setAttribute("y", midy+150);
        SVGObj.setAttribute("font-size", "14");
        SVGObj.setAttribute("text-anchor", "middle");
        SVGObj.textContent = summary_track_off[gene_i][7]
        svg.appendChild(SVGObj);

        SVGObj= document.createElementNS(NS,"text");
        SVGObj.setAttribute("x", midx);
        SVGObj.setAttribute("y", midy+170);
        SVGObj.setAttribute("font-size", "14");
        SVGObj.setAttribute("text-anchor", "middle");
        SVGObj.textContent = summary_track_off[gene_i][3]+ " Reads, (" +divide_zero(summary_track_off[gene_i][3]*100, summary_track_off[gene_i][7]).toFixed(2)+"%)";
        svg.appendChild(SVGObj);

        SVGObj= document.createElementNS(NS,"text");
        SVGObj.setAttribute("x", midx);
        SVGObj.setAttribute("y", midy+190);
        SVGObj.setAttribute("font-size", "14");
        SVGObj.setAttribute("text-anchor", "middle");
        SVGObj.textContent = summary_track_off[gene_i][4]+ " Reads, (" +divide_zero(summary_track_off[gene_i][4]*100,summary_track_off[gene_i][7]).toFixed(2)+"%)" 
        svg.appendChild(SVGObj);

        SVGObj= document.createElementNS(NS,"text");
        SVGObj.setAttribute("x", midx);
        SVGObj.setAttribute("y", midy+210);
        SVGObj.setAttribute("font-size", "14");
        SVGObj.setAttribute("text-anchor", "middle");
        SVGObj.textContent = summary_track_off[gene_i][2] +" Reads, (" +divide_zero(summary_track_off[gene_i][2]*100,summary_track_off[gene_i][7]).toFixed(2) +"%)" 
        svg.appendChild(SVGObj);

        var imageElement = document.createElementNS(NS, "image");
        imageElement.setAttribute("x", midx-15);
        imageElement.setAttribute("y", midy+250);
        if (gene_i !=0 &&summary_track_off[gene_i][7] <5){
            imageElement.setAttribute("href", "crisprnano2/question.svg");
            imageElement.setAttribute("width", 40); // Set the width of the image
            imageElement.setAttribute("height", 40); // Set the height of the image 
        }
        else if (gene_i ==0 || divide_zero(summary_track_off[gene_i][4]*100,summary_track_off[gene_i][7])< 2){
            imageElement.setAttribute("href", "crisprnano2/OK.ico");
            imageElement.setAttribute("width", 40); // Set the width of the image
            imageElement.setAttribute("height", 40); // Set the height of the image 
        }
        else {
            imageElement.setAttribute("href", "crisprnano2/warning.png"); // Set the path to your image file
            imageElement.setAttribute("width", 80); // Set the width of the image
            imageElement.setAttribute("height", 80); // Set the height of the image
            imageElement.setAttribute("x", midx-30);
            imageElement.setAttribute("y", midy+230);
        }
        svg.appendChild(imageElement);
    }

        //legende:
    midx = 25;
    midy = 270;
    for (var i=0; i<3; i++){
        SVGObj= document.createElementNS(NS,"circle");
        SVGObj.setAttributeNS(null, "cx", midx+20*i);
        SVGObj.setAttributeNS(null, "cy", midy);
        SVGObj.setAttributeNS(null, "r" , 6);
        SVGObj.style.fill="none";
        SVGObj.style.fill=BLAU[i];
        svg.appendChild(SVGObj);
    }
    for (var i=0; i<3; i++){
        SVGObj= document.createElementNS(NS,"circle");
        SVGObj.setAttributeNS(null, "cx", midx+20*i);
        SVGObj.setAttributeNS(null, "cy", midy +20);
        SVGObj.setAttributeNS(null, "r" , 6);
        SVGObj.style.fill="none";
        SVGObj.style.fill=ROT[i];
        svg.appendChild(SVGObj);
    }
    SVGObj= document.createElementNS(NS,"circle");
    SVGObj.setAttributeNS(null, "cx", midx+20);
    SVGObj.setAttributeNS(null, "cy", midy +40);
    SVGObj.setAttributeNS(null, "r" , 6);
    SVGObj.style.fill="none";
    SVGObj.style.fill="rgb(200,200,200)";
    svg.appendChild(SVGObj);

    SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("font-family", "sans-serif");
    SVGObj.setAttribute("font-weight", "100");
    SVGObj.setAttribute("x", midx+80);
    SVGObj.setAttribute("y", midy-20);
    SVGObj.setAttribute("font-size", "12");
    SVGObj.textContent = "TOTAL ALIGNED READS "
    svg.appendChild(SVGObj);

    SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("font-family", "sans-serif");
    SVGObj.setAttribute("font-weight", "100");
    SVGObj.setAttribute("x", midx+80);
    SVGObj.setAttribute("y", midy);
    SVGObj.setAttribute("font-size", "12");
    SVGObj.textContent = "in-frame indels: "
    svg.appendChild(SVGObj);
    SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("font-family", "sans-serif");
    SVGObj.setAttribute("font-weight", "100");
    SVGObj.setAttribute("x", midx+80);
    SVGObj.setAttribute("y", midy+20)
    SVGObj.setAttribute("font-size", "12");
    SVGObj.textContent = "out-of-frame indels: "
    svg.appendChild(SVGObj);
    SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("font-family", "sans-serif");
    SVGObj.setAttribute("font-weight", "100");
    SVGObj.setAttribute("x", midx+80);
    SVGObj.setAttribute("y", midy+40)
    SVGObj.setAttribute("font-size", "12");
    SVGObj.textContent = "no indel: "
    svg.appendChild(SVGObj);
 
    document.title = "Off-target Result for "+document.getElementsByName("GeneName")[0].value+" ("+files_name.length+" barcodes read)";
}

function PieClick(evt) {
    var top = document.getElementById("SVGpie").getBoundingClientRect().top;
    var left = document.getElementById("SVGpie").getBoundingClientRect().left;
    var x = evt.clientX-left;
    var y = evt.clientY-top;
    var xx = Math.round((x-25)/50);
    var yy = Math.round((y-25)/65);
    SelectClone(xx+12*yy);
}

function PieClick_rima(evt) {
    var top = document.getElementById("SVGpie_rima").getBoundingClientRect().top;
    var left = document.getElementById("SVGpie_rima").getBoundingClientRect().left;
    var x = evt.clientX-left;
    var y = evt.clientY-top;
    var xx = Math.round((x-25)/50);
    var yy = Math.round((y-25)/65);
    SelectClone(xx+12*yy);
}

function PieClick_off(evt) {
    var top1 = document.getElementById("SVGpie_off").getBoundingClientRect().top;
    var left = document.getElementById("SVGpie_off").getBoundingClientRect().left;
    var x = evt.clientX-left;
    var y = evt.clientY-top1;
    var xx = Math.round((x-300)/180);
    var yy = Math.round((y-100)/65);
    SelectClone_off(xx+12*yy);
}

function SelectClone(barcode) {
    bulkview = document.getElementById("bulkview").checked;
    if (bulkview){
        if (AlignmentPrecalc[barcode]){
            CurrentAlignment = barcode;
            AlignmentStartPos = 0;
            PlotAlignment_bulk(barcode, locus, bulk_threshold)
            document.getElementById("DIV_alignment_bulk").innerHTML = AlignmentPrecalc_bulk;
            PlotAlignment_bulk(barcode, locus, bulk_threshold)
            DrawPie_bulk();
        }
    } 
    else if (AlignmentPrecalc[barcode]) {
        document.getElementById("DIV_alignment").innerHTML = AlignmentPrecalc[barcode];
        CurrentAlignment = barcode;
        AlignmentStartPos = 0;
        PlotAlignment(barcode, locus);
        DrawPie(active_barcode = barcode);
        }
    else alert("No data available for the selected barcode.");
}

function SelectClone_off(barcode) {
    if (AlignmentPrecalc_off[barcode]){
            CurrentAlignment_off = barcode;
            AlignmentStartPos = 0;
            PlotAlignment_off(CurrentAlignment_off)
            document.getElementById("DIV_alignment_off").innerHTML = AlignmentPrecalc_off[barcode];
            PlotAlignment_off(CurrentAlignment_off)
        }
    else alert("No data available for the selected barcode.");
}

function GetWellPos(i) {
    var ABC = "ABCDEFGHIJKL";
    return ABC[Math.floor(i/12)] + ((i%12)+1);
}

//Prepare Alignment function that summaries static variable for plot:

function Pre_PlotAlignment(id, locus){
    //compute number of aligned read
    // check genotype
    // remove low entry
    for (let key in aln_dict[id]){
        if ((aln_dict[id][key][0]<15)){
            delete aln_dict[id][key]
        }
    }

    for (let key in aln_dict[id]){
        sum_track[id] += aln_dict[id][key][0];
    }
    var read_ambigous =0;

    for (let key in aln_dict[id]){
        if (aln_dict[id][key][1]==8){
                read_ambigous++;
        }
    }
    summary_track[id][0] = sum_track[id] + read_ambigous;
    summary_track[id][5] = read_ambigous;
    summary_track[id][6] = 0;
    summary_track[id][8] = 0;

    for (let key in aln_dict[id]){
        if ((aln_dict[id][key][0]>(1*MutationThreshold*sum_track[id]/100))&&(key.split('\n')[0].trim().length>region_analyse*2-4)){
            aln_dict_fil[id][key] = aln_dict[id][key][0];
        }
    }
    // assign new dictionary base on the RTT score
    var validate_ins
    if (rtt){
        //for reupdate RTT
        var ins_arr = []
        for (let key in aln_dict_fil[id]){
            if (key.split('\n')[1].trim().length>5){
                validate_ins = Check_ins_RTT(key, buff_size=5)
                if (validate_ins[0]&&typeof validate_ins[3]!== "undefined"){
                    aln_dict_fil[id][validate_ins[3]]= aln_dict_fil[id][key]
                    aln_dict[id][validate_ins[3]]= aln_dict[id][key]
                    delete aln_dict[id][key]
                    delete aln_dict_fil[id][key]
                    ins_arr.push(validate_ins[4])
                }
            }
        }
        var insertion_pos = findMostPopular(ins_arr)
        for (let key in aln_dict_fil[id]){
            if (key.split('\n')[1].trim().length>0){
                validate_ins = Check_ins_RTT2(key, insertion_pos)
                if (validate_ins[0]){
                    if (typeof validate_ins[3]!== "undefined"){
                        aln_dict_fil[id][validate_ins[3]]= aln_dict_fil[id][key]
                        aln_dict[id][validate_ins[3]]= aln_dict[id][key]
                        delete aln_dict[id][key]
                        delete aln_dict_fil[id][key]
                    }
                }
            }
        }  
    }
    no_indel[id] = 0; 
    no_indel_arr[id] = []
    inf_indel[id] =  0;
    out_indel[id] = 0;
    out_indel_arr[id] = []
    targetingOligo[id] = 0;
    targetingOligo_arr[id] = [];

    for (let key in aln_dict_fil[id]){
        switch (aln_dict[id][key][1]){
            case 1:
                no_indel[id]+=aln_dict[id][key][0];
                no_indel_arr[id][key] = aln_dict[id][key][0];
                break;
            case 2:
                inf_indel[id]+=aln_dict[id][key][0];
                break;
            case 3: 
                out_indel[id]+=aln_dict[id][key][0];
                out_indel_arr[id].push(aln_dict[id][key][0])
                break;
            case 7: 
                targetingOligo[id]+=aln_dict[id][key][0];
                targetingOligo_arr[id].push(aln_dict[id][key][0])
                break;
                // Update desired/ partial edit
            case 9: 
                summary_track[id][6] += aln_dict[id][key][0];
                break;
            case 10: 
                summary_track[id][8] += aln_dict[id][key][0];
                break;
        }
    }
    
    // update new WT candidate, keep maximum
    if (Object.keys(no_indel_arr[id]).length >1){
        let maxValue = -Infinity;
            var sum_wt = 0;
            var candidate_wt;
            for (const key1 in no_indel_arr[id]) {
                const value = no_indel_arr[id][key1];
                if (value > maxValue) {
                    maxValue = value;
                    candidate_wt = key1;
                }
                sum_wt += value;
                delete aln_dict_fil[id][key1];
            }
            //update new candidate WT (max)
            aln_dict_fil[id][candidate_wt] = sum_wt;
    }

    // For saving csv
    summary_track[id][1] = targetingOligo[id];
    summary_track[id][2] = no_indel[id];
    summary_track[id][3] = inf_indel[id];
    summary_track[id][4] = out_indel[id];
    summary_track[id][7] = no_indel[id]+inf_indel[id]+out_indel[id]+targetingOligo[id] + summary_track[id][6] + summary_track[id][8];
    if (summary_track[id][7]>0) {
        summary_track_select[id+1] =  [GetWellPos(id), (summary_track[id][1]/summary_track[id][7]*100).toFixed(2), (summary_track[id][2]/summary_track[id][7]*100).toFixed(2), (summary_track[id][3]/summary_track[id][7]*100).toFixed(2), (summary_track[id][4]/summary_track[id][7]*100).toFixed(2),(summary_track[id][6]*100/summary_track[id][7]).toFixed(2),(summary_track[id][8]*100/summary_track[id][7]).toFixed(2) , summary_track[id][7]]
    }
    else {
        summary_track_select[id+1] =  [GetWellPos(id), summary_track[id][1],  summary_track[id][2], summary_track[id][3], summary_track[id][4],0, 0 ,summary_track[id][7]]
    }

    // check genotype
    if (summary_track[id][7] > 50) {
        if (targetingOligo[id]/summary_track[id][7] > 0.95) {
            if (targetingOligo_arr[id].length==2) {
                if (targetingOligo_arr[id][0]/(targetingOligo_arr[id][0]+targetingOligo_arr[id][1])>0.3 ||targetingOligo_arr[id][0]/(targetingOligo_arr[id][0]+targetingOligo_arr[id][1])<0.7){
                    genotype[id] = 'KI/KI'
                }
                else {
                    genotype[id] = 'KI'
                }
            }
            else {
                    genotype[id] = 'KI'
                }
        }
        else {
            if ((out_indel[id]/summary_track[id][7] > 0.3)&&(out_indel[id]/summary_track[id][7] < 0.7)) {
                genotype[id] = 'HET'
            }
            else if ((out_indel[id]/summary_track[id][7] > 0.3)&&(out_indel[id]/summary_track[id][7] < 0.7)) {
                genotype[id] = 'HET'
            }
            else if ((targetingOligo[id]/summary_track[id][7]<0.7)&& (targetingOligo[id]/summary_track[id][7]>0.7)) {
                genotype[id] = 'HET'
            }
            else if (Object.keys(no_indel_arr[id]).length>1 && no_indel_arr[id][Object.keys(no_indel_arr[id])[0]]/(no_indel_arr[id][Object.keys(no_indel_arr[id])[0]]+no_indel_arr[id][Object.keys(no_indel_arr[id])[1]]) >0.3) {
                genotype[id] = 'HET'
            }
            else if ((out_indel[id]/summary_track[id][7] > 0.98)&& (out_indel_arr[id].length >1)&& (out_indel_arr[id][0]/summary_track[id][7] > 0.20)){ 
                genotype[id] = 'KO'
            }
            else {
                genotype[id] = ''
            }
        }
    }

    // sort aligment tract
    var items = Object.keys(aln_dict_fil[id]).map(function(key) {
    return [key, aln_dict_fil[id][key]];
    });
    // Sort the array based on the second element
    items.sort(function(first, second) {
    return second[1] - first[1];
    });
    aln_dict_fil[id] = Object.fromEntries(items.map(([v, k]) => [v, k]));
}

function PlotAlignment(id, locus){
    rima_hist_all[id] = [0,0,0,0,0]
    var rima_class = 'other EJ'
    var HA = document.getElementById('HA').checked;
    for (let key in aln_dict_fil[id]){
        //aggregate WT
        var micro_homology_data = Check_RIMA(key)
        var duplication1 = Check_duplication(key)
        if (micro_homology_data[0]){
            rima_class = 'other EJ (MH-del 1bp)'
            if (micro_homology_data[0].length>=2){
                rima_class = 'MH-del'
                rima_hist_all[id][0] += aln_dict_fil[id][key]
            }
            else{
                rima_hist_all[id][2] += aln_dict_fil[id][key]
            }
        }
        else if ((micro_homology_data[3]==1)||((micro_homology_data[1]!=-1)&&(micro_homology_data[2]-micro_homology_data[1]==1))){
            rima_class = 'NHEJ'
            rima_hist_all[id][1] += aln_dict_fil[id][key]
        }
        else if (typeof aln_dict[id][key][1] !== "undefined" && aln_dict[id][key][1] ===7){
            if (HA) {
                rima_class = 'NHEJ-KI'
                rima_hist_all[id][3] += aln_dict_fil[id][key]
                }
            else {
                rima_class = 'HDR-KI'
                rima_hist_all[id][4] += aln_dict_fil[id][key]
                }
            }
        else {
            rima_class = 'other EJ'
            rima_hist_all[id][2] += aln_dict_fil[id][key]
        }
    }

    //aggregate aln_track
    //Find top 3:
    var aln_type = ["Not align","No indel", "Inframe Indel", "Outframe indel", "", "","", "targetingOligo", "Ambigious", "DESIRED edit", "PARTIAL edit"]
    var ysize = 30;
    var max=0;
    var rima_sum = rima_hist_all[id][0] +rima_hist_all[id][1]+ rima_hist_all[id][2]+rima_hist_all[id][3]+ rima_hist_all[id][4]

    var aln_dict_bulk_1 = {}
    for (let key in aln_dict_fil[id]){
        if (aln_dict[id][key][1]==9||aln_dict[id][key][1]==10){
            aln_dict_bulk_1[key] = aln_dict_fil[id][key];
        }
    }

    for (let key in aln_dict_fil[id]){
        if (aln_dict[id][key][1]!=9&&aln_dict[id][key][1]!=10){
            aln_dict_bulk_1[key] = aln_dict_fil[id][key];
        }
    }
    aln_dict_fil[id] = aln_dict_bulk_1

    var svg = document.getElementById("SVGmut");
    var NS="http://www.w3.org/2000/svg";
    var svgns = "http://www.w3.org/2000/svg";
    var strokew = "0.5";

    svg.addEventListener("mousedown", AlignmentMouseDown, false);
    svg.addEventListener("mousemove", AlignmentMouseMove, false);
    svg.addEventListener("mouseup", AlignmentMouseUp, false);
    svg.setAttributeNS(null, "onmousedown", "return false;"); //prevents marking

    while (svg.lastChild){
        svg.removeChild(svg.lastChild);
    }

    var delypos=20, delyshift=60;

    //bc, readsum:
    var SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("x", 40);
    SVGObj.setAttribute("y", ysize+delypos);
    SVGObj.setAttribute("font-size", "16");
    SVGObj.setAttribute("font-weight", "600");
    SVGObj.textContent = "SUMMARY: Gene: "+document.getElementsByName("GeneName")[0].value+"   |   File "+GetWellPos(id)+": "+files_name[id];
    svg.appendChild(SVGObj);
    delypos+=30;

    SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("x", 40);
    SVGObj.setAttribute("y", ysize+delypos);
    SVGObj.setAttribute("font-size", "16");
    SVGObj.textContent = "Total aligned reads: " + summary_track[id][7] +"   |  Outframe indel: " +summary_track[id][4]+ " READS, (" +(summary_track[id][4]*100/summary_track[id][7]).toFixed(2)+"%)" +"   |  Inframe indel: " +summary_track[id][3]+ " READS, (" +(summary_track[id][3]*100/summary_track[id][7]).toFixed(2)+"%)";
    svg.appendChild(SVGObj);
    delypos+=30;
    SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("x", 40);
    SVGObj.setAttribute("y", ysize+delypos);
    SVGObj.setAttribute("font-size", "16");
    SVGObj.textContent = "targetingOligo reads: " + summary_track[id][1] +" READS, (" +(summary_track[id][1]*100/summary_track[id][7]).toFixed(2)+"%)"+"   |  No indel: " +summary_track[id][2] +" READS, (" +(summary_track[id][2]*100/summary_track[id][7]).toFixed(2)+"%)" +"   | Read ambigous: " +summary_track[id][5] 
    svg.appendChild(SVGObj);
    delypos+=30;
    if (p_edit!=""||d_edit!=""){
        SVGObj= document.createElementNS(NS,"text");
        SVGObj.setAttribute("x", 40);
        SVGObj.setAttribute("y", ysize+delypos);
        SVGObj.setAttribute("font-size", "16");
        SVGObj.textContent = "Desired edit reads: " + summary_track[id][6]+ " READS, (" +(summary_track[id][6]*100/summary_track[id][7]).toFixed(2)+"%)" +"   |  Partial edit: " +summary_track[id][8] +" READS, (" +(summary_track[id][8]*100/summary_track[id][7]).toFixed(2)+"%)" 
        svg.appendChild(SVGObj);
        delypos+=30;
    }
    SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("x", 40);
    SVGObj.setAttribute("y", ysize+delypos);
    SVGObj.setAttribute("font-size", "16");
    SVGObj.textContent = "MH-del: "+(rima_hist_all[id][0]*100/rima_sum).toFixed(2) +" | NHEJ : " +(rima_hist_all[id][1]*100/rima_sum).toFixed(2) + " | NHEJ-KI : " +(rima_hist_all[id][3]*100/rima_sum).toFixed(2)+" | HDR-KI : " +(rima_hist_all[id][4]*100/rima_sum).toFixed(2)+" | Other EJ : " +(rima_hist_all[id][2]*100/rima_sum).toFixed(2)
    svg.appendChild(SVGObj);
    delypos+=delyshift;

    // Legend RIMA2
    SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("y", ysize+delypos-120);
    SVGObj.setAttribute("font-size", "24");
    SVGObj.setAttribute("fill", N_cl);
    SVGObj.textContent = 'ANNOTATION';
    SVGObj.setAttribute("x", 120+6*(120));
    svg.appendChild(SVGObj);

    SVGObj= document.createElementNS(svgns, "rect");
    SVGObj.setAttribute("x", 120+6*(120));
    SVGObj.setAttribute("y", ysize+delypos-100);
    SVGObj.setAttribute("width", "11");
    SVGObj.setAttribute("height", "11");
    SVGObj.setAttribute("fill", "rgb(255,255,0");
    SVGObj.style.stroke=T_cl;
    SVGObj.setAttribute("pointer-events","none");
    svg.appendChild(SVGObj);
    SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("y", ysize+delypos-90);
    SVGObj.setAttribute("font-size", "14");
    SVGObj.setAttribute("fill", N_cl);
    SVGObj.textContent = 'DUPLICATED INSERTION';
    SVGObj.setAttribute("x", 120+6*120+30);
    svg.appendChild(SVGObj);

    SVGObj= document.createElementNS(svgns, "rect");
    SVGObj.setAttribute("x", 120+6*(120));
    SVGObj.setAttribute("y", ysize+delypos-80);
    SVGObj.setAttribute("width", "11");
    SVGObj.setAttribute("height", "11");
    SVGObj.setAttribute("fill", "rgb(0,255,255");
    SVGObj.setAttribute("text-anchor", "middle");
    SVGObj.setAttribute("pointer-events","none");
    svg.appendChild(SVGObj);
    SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("y", ysize+delypos-70);
    SVGObj.setAttribute("font-size", "14");
    SVGObj.setAttribute("fill", N_cl);
    SVGObj.textContent = 'MICRO HOMOLOGY';
    SVGObj.setAttribute("x", 120+6*120+30);
    svg.appendChild(SVGObj);

    SVGObj= document.createElementNS(svgns, "rect");
    SVGObj.setAttribute("x", 120+6*(120));
    SVGObj.setAttribute("y", ysize+delypos-60);
    SVGObj.setAttribute("width", "11");
    SVGObj.setAttribute("height", "11");
    SVGObj.setAttribute("fill", "rgb(255,255,255");
    SVGObj.setAttribute("text-anchor", "middle");
    SVGObj.style.stroke=T_cl;
    SVGObj.setAttribute("pointer-events","none");
    svg.appendChild(SVGObj);

    SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("y", ysize+delypos-50);
    SVGObj.setAttribute("font-size", "14");
    SVGObj.setAttribute("fill", N_cl);
    SVGObj.textContent = 'NORMAL SNP/INSERTION';
    SVGObj.setAttribute("x", 120+6*120+30);
    svg.appendChild(SVGObj);

    var xfrom = BreakPoint-30 +Math.floor(AlignmentStartPos);
    var xto = xfrom +60;
    //wt: REFERENCES SEQ
    for (let x=xfrom; x<xto; x++){
        //draw base:
        SVGObj= document.createElementNS(NS,"text");
        SVGObj.setAttribute("y", ysize+delypos+20);
        SVGObj.setAttribute("font-size", "14");
        if (x>=RightBsPos && x<RightBsPos+rightbs.length) SVGObj.setAttribute("fill", "rgb(0,0,250)");
        else SVGObj.setAttribute("fill", N_cl);
        SVGObj.textContent = locus[x];
        SVGObj.setAttribute("x", 120+12*(x-xfrom));
        SVGObj.setAttribute("text-anchor", "middle");
        svg.appendChild(SVGObj);
    }
    //sgRNA
    if (rightbs!=getSeq("RightBS")){
        var locus2 = ReverseString(ReverseComplement(locus))
    }
    else{
        var locus2 = locus
    }

    for (let x=RightBsPos; x<RightBsPos+rightbs.length; x++){
        //draw base:
        if (x>xfrom&&x<xto){
            SVGObj= document.createElementNS(NS,"text");
            SVGObj.setAttribute("y", ysize+delypos);
            SVGObj.setAttribute("font-size", "14");
            SVGObj.setAttribute("fill", N_cl);
            SVGObj.textContent = locus2[x];
            SVGObj.setAttribute("x", 120+12*(x-xfrom));
            SVGObj.setAttribute("text-anchor", "middle");
            svg.appendChild(SVGObj);
        }
    }
    
    var imageElement = document.createElementNS(NS, "image");
    if (rightbs!=getSeq("RightBS")){
        imageElement.setAttribute("x", 95+12*(RightBsPos-xfrom )); // Set the x-coordinate of the image
    }    
    else{
        imageElement.setAttribute("x", 120+12*(RightBsPos+rightbs.length-xfrom)+2); // Set the x-coordinate of the image
    }
    imageElement.setAttribute("y", ysize + delypos -20); // Set the y-coordinate of the image
    imageElement.setAttribute("width", 20); // Set the width of the image
    imageElement.setAttribute("height", 20); // Set the height of the image
    imageElement.setAttribute("href", "crisprnano2/scissors.svg"); // Set the path to your image file
    svg.appendChild(imageElement);
    

    //reference:
    SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("x", 1);
    SVGObj.setAttribute("y", ysize+delypos+20);
    SVGObj.setAttribute("font-size", "13");
    SVGObj.textContent += "REFERENCE 5'->3'";
    svg.appendChild(SVGObj);
    //line:
    SVGObj= document.createElementNS(NS,"path");
    SVGObj.setAttributeNS(null, "d", "M 5,"+(ysize+delypos+5.5)+" L 1200,"+(ysize+delypos+5.5));
    SVGObj.style.stroke=N_cl;
    SVGObj.setAttributeNS(null, "stroke-width", 1);
    svg.appendChild(SVGObj);
    delypos+=delyshift;
    var id1 = 1;

    for (let key in aln_dict_fil[id]){
        //aggregate WT
        var micro_homology_data = Check_RIMA(key)
        var duplication1 = Check_duplication(key)
        if (micro_homology_data[0]){
            rima_class = 'other EJ (MH-del 1bp)'
            if (micro_homology_data[0].length>=2){
                rima_class = 'MH-del'
            }
        }
        else if ((micro_homology_data[3]==1)||((micro_homology_data[1]!=-1)&&(micro_homology_data[2]-micro_homology_data[1]==1))){
            rima_class = 'NHEJ'
        }
        else if (typeof aln_dict[id][key][1] !== "undefined" && aln_dict[id][key][1] ===7){
            if (HA) {
                rima_class = 'NHEJ-KI'
                }
            else {
                rima_class = 'HDR-KI'
                }
            }
        else {
            rima_class = 'other EJ'
        }        
        if (rima_class=='MH-del'||rima_class=='other EJ (MH-del 1bp)') { 
            for (let x=xfrom-40; x<xto+10; x++){
                if (((x >= micro_homology_data[1]-xfrom+10)&&(x < micro_homology_data[1]-xfrom+10 + micro_homology_data[0].length))||((x >= micro_homology_data[2]-xfrom+10)&&(x < micro_homology_data[2]-xfrom+10 + micro_homology_data[0].length))){
                        SVGObj= document.createElementNS(svgns, "rect");
                        SVGObj.setAttribute("x", 120+12*(x)-5);
                        SVGObj.setAttribute("y", ysize+delypos-10);
                        SVGObj.setAttribute("width", "11");
                        SVGObj.setAttribute("height", "11");
                        SVGObj.setAttribute("fill", "rgb(0,255,255");
                        SVGObj.setAttribute("text-anchor", "middle");
                        SVGObj.setAttribute("pointer-events","none");
                        svg.appendChild(SVGObj);
                }
            }
        }
        
        if (aln_dict[id][key][1]==1 && (Object.keys(no_indel_arr[id]).length >1)){
            for (let x=xfrom-10; x<xto-10; x++){
            //draw main track:
                if (Object.keys(no_indel_arr[id])[0][x]==Object.keys(no_indel_arr[id])[1][x]){
                    SVGObj= document.createElementNS(NS, "text");
                    SVGObj.setAttribute("y", ysize+delypos);
                    SVGObj.setAttribute("font-size", "13");
                    SVGObj.setAttribute("font-weight", "1200");
                    if (key[x]=="T"){SVGObj.textContent = key[x];
                        SVGObj.setAttribute("fill", T_cl);
                    }
                    else if (key[x]=="A"){SVGObj.textContent = key[x];
                        SVGObj.setAttribute("fill", A_cl);
                    }
                    else if (key[x]=="C"){SVGObj.textContent = key[x];
                        SVGObj.setAttribute("fill", C_cl);
                    }
                    else if (key[x]=="G"){SVGObj.textContent = key[x];
                        SVGObj.setAttribute("fill", G_cl);
                    }
                    else if (key[x]=="N"){SVGObj.textContent = key[x];
                        SVGObj.setAttribute("fill", N_cl);
                    }
                    else if (key[x]=="-"){SVGObj.textContent = key[x];
                        SVGObj.setAttribute("fill", "rgb(0,0,0");
                    }
                    SVGObj.setAttribute("x", 120+12*(x-xfrom+10));
                    SVGObj.setAttribute("text-anchor", "middle");
                    SVGObj.setAttribute("pointer-events","none");
                    svg.appendChild(SVGObj);
                }
                else {
                    var fontsize1 = 4+ Math.floor(13*no_indel_arr[id][Object.keys(no_indel_arr[id])[0]]/(no_indel_arr[id][Object.keys(no_indel_arr[id])[0]]+no_indel_arr[id][Object.keys(no_indel_arr[id])[1]]))
                    var fontsize2 = 4+ Math.floor(13*no_indel_arr[id][Object.keys(no_indel_arr[id])[1]]/(no_indel_arr[id][Object.keys(no_indel_arr[id])[0]]+no_indel_arr[id][Object.keys(no_indel_arr[id])[1]]))
                    SVGObj= document.createElementNS(NS, "text");
                    SVGObj.setAttribute("x", 120+12*(x-xfrom+10));
                    SVGObj.setAttribute("y", ysize+delypos-5);
                    SVGObj.setAttribute("font-size", fontsize1);
                    SVGObj.setAttribute("font-weight", "1200");
                    if (Object.keys(no_indel_arr[id])[0][x]=="T"){SVGObj.setAttribute("fill", T_cl);
                    }
                    else if (Object.keys(no_indel_arr[id])[0][x]=="A"){SVGObj.setAttribute("fill", A_cl);
                    }
                    else if (Object.keys(no_indel_arr[id])[0][x]=="C"){SVGObj.setAttribute("fill", C_cl);
                    }
                    else if (Object.keys(no_indel_arr[id])[0][x]=="G"){SVGObj.setAttribute("fill", G_cl);
                    }
                    else if (Object.keys(no_indel_arr[id])[0][x]=="N"){SVGObj.setAttribute("fill", N_cl);
                    }

                    SVGObj.textContent = Object.keys(no_indel_arr[id])[0][x];
                    SVGObj.setAttribute("text-anchor", "middle");
                    SVGObj.setAttribute("pointer-events","none");
                    svg.appendChild(SVGObj);

                    SVGObj= document.createElementNS(NS, "text");
                    SVGObj.setAttribute("x", 120+12*(x-xfrom+10));
                    SVGObj.setAttribute("y", ysize+delypos+5);
                    SVGObj.setAttribute("font-size", fontsize2);
                    SVGObj.setAttribute("font-weight", "1200");

                    if (Object.keys(no_indel_arr[id])[1][x]=="T"){SVGObj.setAttribute("fill", T_cl);
                    }
                    else if (Object.keys(no_indel_arr[id])[1][x]=="A"){SVGObj.setAttribute("fill", A_cl);
                    }
                    else if (Object.keys(no_indel_arr[id])[1][x]=="C"){SVGObj.setAttribute("fill", C_cl);
                    }
                    else if (Object.keys(no_indel_arr[id])[1][x]=="G"){SVGObj.setAttribute("fill", G_cl);
                    }
                    else if (Object.keys(no_indel_arr[id])[1][x]=="N"){SVGObj.setAttribute("fill", N_cl);
                    }
                    SVGObj.textContent = Object.keys(no_indel_arr[id])[1][x];
                    SVGObj.setAttribute("text-anchor", "middle");
                    SVGObj.setAttribute("pointer-events","none");
                    svg.appendChild(SVGObj);

                    SVGObj= document.createElementNS(NS, "text");
                    SVGObj.setAttribute("y", ysize+delypos+25);
                    SVGObj.setAttribute("font-size", 8);
                    SVGObj.setAttribute("font-weight", "1200");
                    SVGObj.textContent = no_indel_arr[id][Object.keys(no_indel_arr[id])[1]] + " "+Object.keys(no_indel_arr[id])[1][x]
                    SVGObj.setAttribute("x", 120+12*(x-xfrom+10));
                    SVGObj.setAttribute("text-anchor", "middle");
                    SVGObj.setAttribute("pointer-events","none");
                    svg.appendChild(SVGObj);

                    SVGObj= document.createElementNS(NS, "text");
                    SVGObj.setAttribute("y", ysize+delypos+15);
                    SVGObj.setAttribute("font-size", 8);
                    SVGObj.setAttribute("font-weight", "1200");
                    SVGObj.textContent = no_indel_arr[id][Object.keys(no_indel_arr[id])[0]] + " " +Object.keys(no_indel_arr[id])[0][x]
                    SVGObj.setAttribute("x", 120+12*(x-xfrom+10));
                    SVGObj.setAttribute("text-anchor", "middle");
                    SVGObj.setAttribute("pointer-events","none");
                    svg.appendChild(SVGObj);
                }
            }
        }
        else {
            for (let x=xfrom-10; x<xto-10; x++){
                //draw main track:
                if (
                    (x >= 0 && x < key.length && (BreakPoint-region_analyse+x) >= 0 && (BreakPoint-region_analyse+x) < locus.length && key[x] == locus[BreakPoint-region_analyse+x])
                    || (key[x] == 'N')
                    || (key[x] == '-')
                    || (typeof(key[x]) == 'undefined')
                ){
                    if ((duplication1[0])&&(x>=duplication1[1])&&(x<(duplication1[1]+duplication1[2]))){
                        SVGObj= document.createElementNS(svgns, "rect");
                        SVGObj.setAttribute("fill", "rgb(255,255,0");
                        SVGObj.style.stroke=T_cl;
                        SVGObj.setAttribute("x", 120+12*(x-xfrom+10)-5);
                        SVGObj.setAttribute("y", ysize+delypos-10);
                        SVGObj.setAttribute("width", "12");
                        SVGObj.setAttribute("height", "12");
                        SVGObj.setAttribute("text-anchor", "middle");
                        SVGObj.setAttribute("pointer-events","none");
                        svg.appendChild(SVGObj);
                        }
                    SVGObj= document.createElementNS(NS, "text");
                    SVGObj.setAttribute("font-weight", "1200");
                }
                else if ('ACTGN'.includes(key[x])){
                    SVGObj= document.createElementNS(svgns, "rect");
                    SVGObj.style.stroke=N_cl;
                    SVGObj.setAttribute("x", 115+12*(x-xfrom+10));
                    SVGObj.setAttribute("y", ysize+delypos-10);
                    SVGObj.setAttribute("width", "11");
                    SVGObj.setAttribute("height", "11");
                    SVGObj.setAttribute("fill", "rgb(255,255,255");
                    SVGObj.setAttribute("text-anchor", "middle");
                    SVGObj.setAttribute("pointer-events","none");
                    svg.appendChild(SVGObj);
                    SVGObj= document.createElementNS(NS, "text");
                    SVGObj.setAttribute("font-weight", "600");
                }
                SVGObj= document.createElementNS(NS, "text");
                SVGObj.setAttribute("font-weight", "1200");
                SVGObj.setAttribute("x", 115+12*(x-xfrom+10));
                SVGObj.setAttribute("y", ysize+delypos);
                SVGObj.setAttribute("font-size", "13");

                if (key[x]=="T"){SVGObj.textContent = key[x];
                    SVGObj.setAttribute("fill", T_cl);
                }
                else if (key[x]=="A"){SVGObj.textContent = key[x];
                    SVGObj.setAttribute("fill", A_cl);
                }
                else if (key[x]=="C"){SVGObj.textContent = key[x];
                    SVGObj.setAttribute("fill", C_cl);
                }
                else if (key[x]=="G"){SVGObj.textContent = key[x];
                    SVGObj.setAttribute("fill", G_cl);
                }
                else if (key[x]=="N"){SVGObj.textContent = key[x];
                    SVGObj.setAttribute("fill", N_cl);
                }
                else if (key[x]=="-"){SVGObj.textContent = key[x];
                    SVGObj.setAttribute("fill", N_cl);
                }
                SVGObj.setAttribute("x", 120+12*(x-xfrom+10));
                SVGObj.setAttribute("text-anchor", "middle");
                SVGObj.setAttribute("pointer-events","none");
                svg.appendChild(SVGObj); 
            }
        }
        
        var image_loc = 0;
        for (let x=xfrom-10; x<xto-10; x++){
            if (x>0){
                //draw insert:
                SVGObj= document.createElementNS(svgns, "rect");
                if ('ACTG'.includes(key[x+region_analyse*2])){
                    if (image_loc == 0){
                        const line = document.createElementNS(NS, "line");
                        // Set line attributes to make it vertical
                        line.setAttribute("x1", 120+12*(x-xfrom+10)-18);
                        line.setAttribute("y1", ysize+delypos-14);
                        line.setAttribute("x2", 120+12*(x-xfrom+10)-18);
                        line.setAttribute("y2", ysize+delypos+20);
                        line.setAttribute("stroke", "blue");
                        line.setAttribute("stroke-width", "3");
                        svg.appendChild(line);
                        image_loc =1;
                    }
                    if (duplication1[0]){
                        SVGObj.setAttribute("fill", "rgb(255,255,0");
                    }
                    else{
                        SVGObj.setAttribute("fill", "rgb(255,255,255");
                    }
                    SVGObj.style.stroke=T_cl;
                    SVGObj.setAttribute("x", 120+12*(x-xfrom+9)-4);
                    SVGObj.setAttribute("y", ysize+delypos+4);
                    SVGObj.setAttribute("width", "12");
                    SVGObj.setAttribute("height", "12");
                    SVGObj.setAttribute("text-anchor", "middle");
                    SVGObj.setAttribute("pointer-events","none");
                    svg.appendChild(SVGObj);
                }

                SVGObj= document.createElementNS(NS,"text");
                SVGObj.setAttribute("x", 120+12*(x-xfrom+9)+1);
                SVGObj.setAttribute("y", ysize+delypos+15);
                SVGObj.setAttribute("font-size", "13");
                SVGObj.setAttribute("fill", N_cl);
                SVGObj.textContent = key[x+region_analyse*2];
                SVGObj.setAttribute("text-anchor", "middle");
                SVGObj.setAttribute("pointer-events","none");
                svg.appendChild(SVGObj);
            }
        }

        for (let x=xfrom-10; x<xto-10; x++){
            if (x>0){
                //draw RTT:
                SVGObj= document.createElementNS(NS,"text");
                SVGObj.setAttribute("x", 120+12*(x-xfrom+9)+1);
                SVGObj.setAttribute("y", ysize+delypos+30);
                SVGObj.setAttribute("font-size", "13");
                SVGObj.setAttribute("fill", N_cl);
                SVGObj.textContent = key[x+region_analyse*4+1];
                SVGObj.setAttribute("text-anchor", "middle");
                SVGObj.setAttribute("pointer-events","none");
                svg.appendChild(SVGObj);
            }
        }
        
        SVGObj= document.createElementNS(NS,"text");
        SVGObj.setAttribute("x", 1);
        SVGObj.setAttribute("y", ysize+delypos);
        SVGObj.setAttribute("font-size", "14");
        SVGObj.textContent += "GROUP " +id1;
        svg.appendChild(SVGObj);

        SVGObj= document.createElementNS(NS,"text");
        SVGObj.setAttribute("x", 10+ 120+24*(30)+2 );
        SVGObj.setAttribute("y", ysize+delypos);
        SVGObj.setAttribute("font-size", "14");
        // Count INDEL's length
        var gap_len1 = key.substring(region_analyse*2 +1, region_analyse*4).replace(/-/g, "").replace(/\s+/g, "").length -  (key.substring(0, region_analyse*2).split("-").length-1)
        SVGObj.textContent +="TYPE: "+ aln_type[aln_dict[id][key][1]] + ", (" + gap_len1 + " bp)" +" | " +aln_dict_fil[id][key] +"  Reads, " + (aln_dict_fil[id][key]/summary_track[id][7]*100).toFixed(2) + " %";
        svg.appendChild(SVGObj);

        SVGObj= document.createElementNS(NS,"text");
        SVGObj.setAttribute("x", 10+ 120+24*(30)+2 );
        SVGObj.setAttribute("y", ysize+delypos+13);
        SVGObj.setAttribute("font-size", "14");
        if (rima_class == 'NHEJ'){
            SVGObj.setAttribute("fill", "rgb(17, 94, 94)");
        }
        else if (rima_class == 'other EJ'){
            SVGObj.setAttribute("fill", "rgb(153, 151, 151)");
        }
        else if (rima_class == 'MH-del'){
            SVGObj.setAttribute("fill", "rgb(84, 199, 199)");
        }
        else if (rima_class == 'NHEJ-KI'){
            SVGObj.setAttribute("fill", "rgb(154, 34, 93)");
        }
        else if (rima_class == 'HDR-KI'){
            SVGObj.setAttribute("fill", "rgb(16,115,179)");
        }

        SVGObj.textContent +="RIMA classified as: "+ rima_class;
        svg.appendChild(SVGObj);

        id1+=1;
        delypos+=delyshift;
    }
    AlignmentPrecalc[id] = document.getElementById("DIV_alignment").innerHTML;
}

function PlotAlignment_bulk(barcode, locus, bulk_threshold = bulk_threshold){
    //compute number of aligned read in bulk mode
    // check genotype 
    var id = barcode;
    aln_dict_bulk = {}
    for (let key in aln_dict[id]){
        if ((aln_dict[id][key][0]>10)&&(aln_dict[id][key][0]>(1*bulk_threshold*summary_track[id][0]/100))&&(key.split('\n')[0].trim().length>region_analyse*2-4)){
            aln_dict_bulk[key] = aln_dict[id][key][0];
        }
    }
    
    // sort aligment tract
    var items = Object.keys(aln_dict_bulk).map(function(key) {
        return [key, aln_dict_bulk[key]];
    });

    // Sort the array based on the second element
    items.sort(function(first, second) {
        return second[1] - first[1];
    });
    aln_dict_bulk = Object.fromEntries(items.map(([v, k]) => [v, k]));
    var aln_dict_bulk_1 = {}
    for (let key in aln_dict_bulk){
        if (aln_dict[id][key][1]==9||aln_dict[id][key][1]==10){
            aln_dict_bulk_1[key] = aln_dict_bulk[key];
        }
    }

    for (let key in aln_dict_bulk){
        if (aln_dict[id][key][1]!=9&&aln_dict[id][key][1]!=10){
            aln_dict_bulk_1[key] = aln_dict_bulk[key];
        }
    }
    aln_dict_bulk = aln_dict_bulk_1
    
    var sum_bulk = 0
    for (let key in aln_dict_bulk){
        sum_bulk += aln_dict_bulk[key]
    }
    const svgHeight = 150+ Object.keys(aln_dict_bulk).length *80

    //aggregate aln_track
    //Find top 3:
    var aln_type = ["Not align","No indel", "Inframe Indel", "Outframe indel", "", "","", "targetingOligo", "Ambigious", "DESIRED edit", "PARTIAL edit"]
    var ysize = 30;
    var max=0;
    
    var svg = document.getElementById("SVGmut_bulk");
    var NS="http://www.w3.org/2000/svg";
    var svgns = "http://www.w3.org/2000/svg";
    var strokew = "0.5";
    svg.setAttribute("height", svgHeight);

    svg.addEventListener("mousedown", AlignmentMouseDown, false);
    svg.addEventListener("mousemove", AlignmentMouseMove_bulk, false);
    svg.addEventListener("mouseup", AlignmentMouseUp, false);
    svg.setAttributeNS(null, "onmousedown", "return false;"); //prevents marking

    while (svg.lastChild){
        svg.removeChild(svg.lastChild);
    }

    var delypos=20, delyshift=60;

    //bc, readsum:
    delypos+=delyshift;

      // Legend RIMA2
    SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("y", ysize+delypos-70);
    SVGObj.setAttribute("font-size", "24");
    SVGObj.setAttribute("fill", N_cl);
    SVGObj.textContent = 'ANNOTATION';
    SVGObj.setAttribute("x", 120+6*(120));
    svg.appendChild(SVGObj);

    SVGObj= document.createElementNS(svgns, "rect");
    SVGObj.setAttribute("x", 120+6*(120));
    SVGObj.setAttribute("y", ysize+delypos-60);
    SVGObj.setAttribute("width", "11");
    SVGObj.setAttribute("height", "11");
    SVGObj.setAttribute("fill", "rgb(255,255,0");
    SVGObj.style.stroke=T_cl;
    SVGObj.setAttribute("pointer-events","none");
    svg.appendChild(SVGObj);
    SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("y", ysize+delypos-50);
    SVGObj.setAttribute("font-size", "14");
    SVGObj.setAttribute("fill", N_cl);
    SVGObj.textContent = 'DUPLICATED INSERTION';
    SVGObj.setAttribute("x", 120+6*120+30);
    svg.appendChild(SVGObj);

    SVGObj= document.createElementNS(svgns, "rect");
    SVGObj.setAttribute("x", 120+6*(120));
    SVGObj.setAttribute("y", ysize+delypos-40);
    SVGObj.setAttribute("width", "11");
    SVGObj.setAttribute("height", "11");
    SVGObj.setAttribute("fill", "rgb(0,255,255");
    SVGObj.setAttribute("text-anchor", "middle");
    SVGObj.setAttribute("pointer-events","none");
    svg.appendChild(SVGObj);
    SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("y", ysize+delypos-30);
    SVGObj.setAttribute("font-size", "14");
    SVGObj.setAttribute("fill", N_cl);
    SVGObj.textContent = 'MICRO HOMOLOGY';
    SVGObj.setAttribute("x", 120+6*120+30);
    svg.appendChild(SVGObj);

    SVGObj= document.createElementNS(svgns, "rect");
    SVGObj.setAttribute("x", 120+6*(120));
    SVGObj.setAttribute("y", ysize+delypos-20);
    SVGObj.setAttribute("width", "11");
    SVGObj.setAttribute("height", "11");
    SVGObj.setAttribute("fill", "rgb(255,255,255");
    SVGObj.setAttribute("text-anchor", "middle");
    SVGObj.style.stroke=T_cl;
    SVGObj.setAttribute("pointer-events","none");
    svg.appendChild(SVGObj);

    SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("y", ysize+delypos-10);
    SVGObj.setAttribute("font-size", "14");
    SVGObj.setAttribute("fill", N_cl);
    SVGObj.textContent = 'NORMAL SNP/INSERTION';
    SVGObj.setAttribute("x", 120+6*120+30);
    svg.appendChild(SVGObj);


    var xfrom = BreakPoint-30 +Math.floor(AlignmentStartPos);
    var xto = xfrom +60;
    //wt: REFERENCES SEQ
    for (let x=xfrom; x<xto; x++){
        //draw base:
        SVGObj= document.createElementNS(NS,"text");
        SVGObj.setAttribute("y", ysize+delypos+20);
        SVGObj.setAttribute("font-size", "14");
        if (x>=RightBsPos && x<RightBsPos+rightbs.length) SVGObj.setAttribute("fill", "rgb(0,0,250)");
        else SVGObj.setAttribute("fill", "rgb(0,0,0)");
        SVGObj.textContent = locus[x];
        SVGObj.setAttribute("x", 120+12*(x-xfrom));
        SVGObj.setAttribute("text-anchor", "middle");
        svg.appendChild(SVGObj);
    }
    //sgRNA
    if (rightbs!=getSeq("RightBS")){
        var locus2 = ReverseString(ReverseComplement(locus))
    }
    else{
        var locus2 = locus
    }

    for (let x=RightBsPos; x<RightBsPos+rightbs.length; x++){
        if (x>xfrom&&x<xto){
            //draw base:
            SVGObj= document.createElementNS(NS,"text");
            SVGObj.setAttribute("y", ysize+delypos);
            SVGObj.setAttribute("font-size", "14");
            SVGObj.setAttribute("fill", "rgb(0,0,0)");
            SVGObj.textContent = locus2[x];
            SVGObj.setAttribute("x", 120+12*(x-xfrom));
            SVGObj.setAttribute("text-anchor", "middle");
            svg.appendChild(SVGObj);
        }
    }
    
    var imageElement = document.createElementNS(NS, "image");
    if (rightbs!=getSeq("RightBS")){
        imageElement.setAttribute("x", 95+12*(RightBsPos-xfrom )); // Set the x-coordinate of the image
    }    
    else{
        imageElement.setAttribute("x", 120+12*(RightBsPos+rightbs.length-xfrom)+2); // Set the x-coordinate of the image
    }
    imageElement.setAttribute("y", ysize + delypos -20); // Set the y-coordinate of the image
    imageElement.setAttribute("width", 20); // Set the width of the image
    imageElement.setAttribute("height", 20); // Set the height of the image
    imageElement.setAttribute("href", "https://crisprnano.de/crisprnano2/scissors.svg"); // Set the path to your image file
    svg.appendChild(imageElement);

    //reference:
    SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("x", 1);
    SVGObj.setAttribute("y", ysize+delypos+20);
    SVGObj.setAttribute("font-size", "13");
    SVGObj.textContent += "REFERENCE 5'->3'";
    svg.appendChild(SVGObj);
    //line:
    SVGObj= document.createElementNS(NS,"path");
    SVGObj.setAttributeNS(null, "d", "M 5,"+(ysize+delypos+5.5)+" L 1200,"+(ysize+delypos+5.5));
    SVGObj.style.stroke="rgb(0,0,0)";
    SVGObj.setAttributeNS(null, "stroke-width", 1);
    svg.appendChild(SVGObj);
    delypos+=delyshift;
    var id1 = 1;

    //for indel plot
    var indel_info = []
    var indel_info_dist = []
    indel_info_hist = []

    for (let key in aln_dict_bulk){
        //aggregate WT
        var micro_homology_data = Check_RIMA(key)
        var duplication1 = Check_duplication(key)
        var rima_class = 'other EJ'
        if (micro_homology_data[0]){
            rima_class = 'other EJ (MH-del 1bp)'
            if (micro_homology_data[0].length>=2){
                rima_class = 'MH-del';
            }
        }
        else if ((micro_homology_data[3]==1)||((micro_homology_data[1]!=-1)&&(micro_homology_data[2]-micro_homology_data[1]==1))){
            var rima_class = 'NHEJ'        }
        else {
            rima_class = 'other EJ'
        }
         
        if (rima_class=='MH-del'||rima_class=='other EJ (MH-del 1bp)') { 
            for (let x=xfrom-40; x<xto+10; x++){
                if (((x >= micro_homology_data[1]-xfrom+10)&&(x < micro_homology_data[1]-xfrom+10 + micro_homology_data[0].length))||((x >= micro_homology_data[2]-xfrom+10)&&(x < micro_homology_data[2]-xfrom+10 + micro_homology_data[0].length))){
                    SVGObj= document.createElementNS(svgns, "rect");
                    SVGObj.setAttribute("x", 120+12*(x)-5);
                    SVGObj.setAttribute("y", ysize+delypos-10);
                    SVGObj.setAttribute("width", "11");
                    SVGObj.setAttribute("height", "11");
                    SVGObj.setAttribute("fill", "rgb(0,255,255");
                    SVGObj.setAttribute("text-anchor", "middle");
                    SVGObj.setAttribute("pointer-events","none");
                    svg.appendChild(SVGObj);
                }
            }
        }
        
            for (let x=xfrom-10; x<xto-10; x++){
                //draw main track:
                if ((key[x]==locus[BreakPoint-region_analyse+x])||(key[x]=='N')||(key[x]=='-')||(typeof(key[x])=='undefined')){
                    if ((duplication1[0])&&(x>=duplication1[1])&&(x<(duplication1[1]+duplication1[2]))){
                        SVGObj= document.createElementNS(svgns, "rect");
                        SVGObj.setAttribute("fill", "rgb(255,255,0");
                        SVGObj.style.stroke=T_cl;
                        SVGObj.setAttribute("x", 120+12*(x-xfrom+10)-5);
                        SVGObj.setAttribute("y", ysize+delypos-10);
                        SVGObj.setAttribute("width", "12");
                        SVGObj.setAttribute("height", "12");
                        SVGObj.setAttribute("text-anchor", "middle");
                        SVGObj.setAttribute("pointer-events","none");
                        svg.appendChild(SVGObj);
                        }
                    SVGObj= document.createElementNS(NS, "text");
                    SVGObj.setAttribute("font-weight", "800");
                }
                else if ("ACTG".includes(key[x])){
                    SVGObj= document.createElementNS(svgns, "rect");
                    SVGObj.style.stroke=N_cl;
                    SVGObj.setAttribute("x", 115+12*(x-xfrom+10));
                    SVGObj.setAttribute("y", ysize+delypos-10);
                    SVGObj.setAttribute("width", "11");
                    SVGObj.setAttribute("height", "11");
                    SVGObj.setAttribute("fill", "rgb(255,255,255");
                    SVGObj.setAttribute("text-anchor", "middle");
                    SVGObj.setAttribute("pointer-events","none");
                    svg.appendChild(SVGObj);
                    SVGObj= document.createElementNS(NS, "text");
                    SVGObj.setAttribute("font-weight", "800");
                }
                SVGObj= document.createElementNS(NS, "text");
                SVGObj.setAttribute("x", 115+12*(x-xfrom+10));
                SVGObj.setAttribute("font-weight", "800");
                SVGObj.setAttribute("y", ysize+delypos);
                SVGObj.setAttribute("font-size", "13");

                if (key[x]=="T"){SVGObj.textContent = key[x];
                    SVGObj.setAttribute("fill", T_cl);
                }
                else if (key[x]=="A"){SVGObj.textContent = key[x];
                    SVGObj.setAttribute("fill", A_cl);
                }
                else if (key[x]=="C"){SVGObj.textContent = key[x];
                    SVGObj.setAttribute("fill", C_cl);
                }
                else if (key[x]=="G"){SVGObj.textContent = key[x];
                    SVGObj.setAttribute("fill", G_cl);
                }
                else if (key[x]=="N"){SVGObj.textContent = key[x];
                    SVGObj.setAttribute("fill", N_cl);
                }
                else if (key[x]=="-"){SVGObj.textContent = key[x];
                    SVGObj.setAttribute("fill", N_cl);
                }
                SVGObj.setAttribute("x", 120+12*(x-xfrom+10));
                SVGObj.setAttribute("text-anchor", "middle");
                SVGObj.setAttribute("pointer-events","none");
                svg.appendChild(SVGObj); 
            }
        // }
        
        var image_loc = 0;
        for (let x=xfrom-10; x<xto-10; x++){
            if (x>0){
            //draw insert:
            SVGObj= document.createElementNS(svgns, "rect");
            // if ((key[x+region_analyse*2]!="\xa0")&&(key[x+region_analyse*2]!="\n")){
            if ('ACTG'.includes(key[x+region_analyse*2])){
                if (image_loc == 0){
                    const line = document.createElementNS(NS, "line");
                    // Set line attributes to make it vertical
                    line.setAttribute("x1", 120+12*(x-xfrom+10)-18);
                    line.setAttribute("y1", ysize+delypos-14);
                    line.setAttribute("x2", 120+12*(x-xfrom+10)-18);
                    line.setAttribute("y2", ysize+delypos+20);
                    line.setAttribute("stroke", "blue");
                    line.setAttribute("stroke-width", "3");
                    svg.appendChild(line);
                    image_loc =1;
                }
                if (duplication1[0]){
                    SVGObj.setAttribute("fill", "rgb(255,255,0");
                }
                else{
                    SVGObj.setAttribute("fill", "rgb(255,255,255");
                }
                SVGObj.style.stroke=T_cl;
                SVGObj.setAttribute("x", 120+12*(x-xfrom+9)-4);
                SVGObj.setAttribute("y", ysize+delypos+4);
                SVGObj.setAttribute("width", "12");
                SVGObj.setAttribute("height", "12");
                SVGObj.setAttribute("text-anchor", "middle");
                SVGObj.setAttribute("pointer-events","none");
                svg.appendChild(SVGObj);
            }

            SVGObj= document.createElementNS(NS,"text");
            SVGObj.setAttribute("x", 120+12*(x-xfrom+9)+1);
            SVGObj.setAttribute("y", ysize+delypos+15);
            SVGObj.setAttribute("font-size", "13");
            SVGObj.setAttribute("fill", N_cl);
            SVGObj.textContent = key[x+region_analyse*2];
            SVGObj.setAttribute("text-anchor", "middle");
            SVGObj.setAttribute("pointer-events","none");
            svg.appendChild(SVGObj);
            }
        }

        for (let x=xfrom-10; x<xto-10; x++){
            if (x>0){
                //draw RTT:
                SVGObj= document.createElementNS(NS,"text");
                SVGObj.setAttribute("x", 120+12*(x-xfrom+9)+1);
                SVGObj.setAttribute("y", ysize+delypos+30);
                SVGObj.setAttribute("font-size", "13");
                SVGObj.setAttribute("fill", N_cl);
                SVGObj.textContent = key[x+region_analyse*4+1];
                SVGObj.setAttribute("text-anchor", "middle");
                SVGObj.setAttribute("pointer-events","none");
                svg.appendChild(SVGObj);
            }
        }
        
        SVGObj= document.createElementNS(NS,"text");
        SVGObj.setAttribute("x", 1);
        SVGObj.setAttribute("y", ysize+delypos);
        SVGObj.setAttribute("font-size", "14");
        SVGObj.textContent += "GROUP " +id1;
        svg.appendChild(SVGObj);

        SVGObj= document.createElementNS(NS,"text");
        SVGObj.setAttribute("x", 10+ 120+24*(30)+2 );
        SVGObj.setAttribute("y", ysize+delypos);
        SVGObj.setAttribute("font-size", "14");
        // Count INDEL's length
        var gap_len1 = key.substring(region_analyse*2 +1, region_analyse*4).replace(/-/g, "").replace(/\s+/g, "").length -  (key.substring(0, region_analyse*2).split("-").length-1)

        SVGObj.textContent +="TYPE: "+ aln_type[aln_dict[barcode][key][1]] + ", (" + gap_len1 + " bp)" +" | " +aln_dict_bulk[key] +"  Reads, " + (aln_dict_bulk[key]/sum_bulk*100).toFixed(2) + " %";
        if (gap_len1*1<0){
            loc_indel = key.search('-') -BreakPoint;
            if (rightbs!=getSeq("RightBS")){
                indel_info.push([gap_len1, loc_indel + rightbs.length])
            }
            else {
                indel_info.push([gap_len1, loc_indel])
            }
        } 
        else if (gap_len1*1>0){
            var ins_str = key.split('\n')[1]
            var tmp_ins = -1000
            for (let i = 0; i < ins_str.length; i++) {
                if ("ACTG".includes(ins_str[i])&&tmp_ins==-1000) {
                    loc_indel = i - BreakPoint
                    tmp_ins = 1
                    if (rightbs!=getSeq("RightBS")){
                        indel_info.push([gap_len1, loc_indel + rightbs.length])
                        }
                        else {
                            indel_info.push([gap_len1, loc_indel])
                        }
                }
            }
        }
        svg.appendChild(SVGObj);

        SVGObj= document.createElementNS(NS,"text");
        SVGObj.setAttribute("x", 10+ 120+24*(30)+2 );
        SVGObj.setAttribute("y", ysize+delypos+13);
        SVGObj.setAttribute("font-size", "14");
        if (rima_class == 'NHEJ'){
            SVGObj.setAttribute("fill", "rgb(17, 94, 94)");
        }
        else if (rima_class == 'other EJ'){
            SVGObj.setAttribute("fill", "rgb(153, 151, 151)");
        }
        else if (rima_class == 'MH-del'){
            SVGObj.setAttribute("fill", "rgb(84, 199, 199)");
        }

        SVGObj.textContent +="RIMA classified as: "+ rima_class;
        svg.appendChild(SVGObj);

        id1+=1;
        delypos+=delyshift;
    }

    AlignmentPrecalc_bulk = document.getElementById("DIV_alignment_bulk").innerHTML;

    if (indel_info.length !=0){
        const uniqueArray = indel_info.filter((arr, index, self) => 
            index === self.findIndex((a) => 
                a.toString() === arr.toString()
            )
        );
        indel_info= uniqueArray
        // Set layout
        const transposedData = indel_info[0].map((col, i) => indel_info.map(row => row[i]));
        var xValues = transposedData[1];
        var yValues = transposedData[0];

    }
    else {
        var xValues = [];
        var yValues = [];
    }

      // Separate positive and negative values
    const positiveX = [];
    const positiveY = [];
    const negativeX = [];
    const negativeY = [];

    for (let i = 0; i < yValues.length; i++) {
        if (yValues[i] >= 0) {
        positiveX.push(xValues[i]);
        positiveY.push(yValues[i]);
        } else {
        negativeX.push(xValues[i]);
        negativeY.push(yValues[i]);
        }
    }

      // Creating traces for positive and negative values
        const tracePositive = {
            x: positiveX,
            y: positiveY,
            type: 'bar',
            marker: {
            color: 'blue'
            },
            name: 'INSERTION',
            text: positiveX.map((xVal, index) => `Indel Loc: ${xVal}, Indel Size: ${positiveY[index]}`), // Display x and y values on positive bars
            textposition: 'auto'
        };

        const traceNegative = {
            x: negativeX,
            y: negativeY,
            type: 'bar',
            marker: {
            color: 'orange'
            },
            name: 'DELETION',
            text: negativeX.map((xVal, index) => `Indel Loc: ${xVal}, Indel Size: ${negativeY[index]}`), // Display x and y values on negative bars
            textposition: 'auto'
        };

        const layout = {
        title: 'Indel Size and Location',
        xaxis: {
        title: 'Indel Size and Location',
        range: [-80, 80]
        },
        yaxis: {
        title: 'Indel size (bp)'
        },
        legend: {
        x: 1,
        xanchor: 'left',
        y: 1,
        showlegend: true
        }
    };
    // Plot
    Plotly.newPlot('Indel_plot', [tracePositive, traceNegative], layout);
}

//Alignment summary plot:
function Pre_PlotAlignment_off(gene_i) {
    var id = gene_i;
    var barcode = gene_i;
    for (let key in aln_dict_off[id]){
        if (aln_dict_off[id][key][0]>5&&key!='undefined'){
            sum_track_off[id] += aln_dict_off[id][key][0];
        }
    }

    for (let key in aln_dict_off[id]){
        if ((aln_dict_off[id][key][1]!=8)&&(aln_dict_off[id][key][0]>10)&&(aln_dict_off[id][key][0]>(MutationThreshold*sum_track_off[id]/100))&&(key.split('\n')[0].trim().length>region_analyse*2-4)){
            aln_dict_fil_off[id][key] = aln_dict_off[id][key][0];
        }
    }
    
    var no_indel = 0; 
    var no_indel_arr = []
    var inf_indel =  0;
    var out_indel = 0;
    var out_indel_arr = []
    var inf_indel_arr = []

    var sum = 0;

    for (let key in aln_dict_fil_off[id]){
        switch (aln_dict_off[id][key][1]){
            case 1:
                no_indel+=aln_dict_fil_off[id][key];
                no_indel_arr[key] = aln_dict_fil_off[id][key];
                break;
            case 2:
                inf_indel+=aln_dict_fil_off[id][key];
                inf_indel_arr.push(aln_dict_fil_off[id][key])
                break;
            case 3: 
                out_indel+=aln_dict_fil_off[id][key];
                out_indel_arr.push(aln_dict_fil_off[id][key])
                break;
        }
    }
    
    //update new WT candidate, keep maximum
    if (Object.keys(no_indel_arr).length >1){
        let maxValue = -Infinity;
            var sum_wt = 0;
            var candidate_wt;
            for (const key1 in no_indel_arr) {
                const value = no_indel_arr[key1];
                if (value > maxValue) {
                maxValue = value;
                candidate_wt = key1;
                }
                sum_wt += value;
                delete aln_dict_fil_off[id][key1];
            }
            //update new candidate WT (max)
            aln_dict_fil_off[id][candidate_wt] = sum_wt;
    }

    // For saving csv
    summary_track_off[id][2] = no_indel;
    summary_track_off[id][3] = inf_indel;
    summary_track_off[id][4] = out_indel;
    summary_track_off[id][7] = no_indel+inf_indel+out_indel;

    // sort aligment tract
    var items = Object.keys(aln_dict_fil_off[id]).map(function(key) {
    return [key, aln_dict_fil_off[id][key]];
    });
    // Sort the array based on the second element
    items.sort(function(first, second) {
    return second[1] - first[1];
    });
    aln_dict_fil_off[id] = Object.fromEntries(items.map(([v, k]) => [v, k]));
}

function PlotAlignment_off(gene_i) {  
    var id = gene_i;
    var barcode = gene_i;  
    //aggregate aln_track
    //Find top 3:
    var aln_type = ["Not align","No indel", "Inframe Indel", "Outframe indel", "", "","", "targetingOligo", "Ambigious"]
    var ysize = 30;
    var max=0;
    
    var svg = document.getElementById("SVGmut_off");
    var NS="http://www.w3.org/2000/svg";
    var svgns = "http://www.w3.org/2000/svg";
    var strokew = "0.5";

    svg.addEventListener("mousedown", AlignmentMouseDown, false);
    svg.addEventListener("mousemove", AlignmentMouseMove_off, false);
    svg.addEventListener("mouseup", AlignmentMouseUp, false);
    svg.setAttributeNS(null, "onmousedown", "return false;"); //prevents marking

    while (svg.lastChild){
        svg.removeChild(svg.lastChild);
    }

    var delypos=20, delyshift=60;

    //bc, readsum:
    var SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("x", 40);
    SVGObj.setAttribute("y", ysize+delypos);
    SVGObj.setAttribute("font-size", "17");
    SVGObj.setAttribute("font-weight", "700");
    SVGObj.textContent = "OFF-TARGET ALIGNMENT SUMMARY: Gene: "+gene_list[gene_i]+"   |   File "+files[CurrentFileId_off].name;
    svg.appendChild(SVGObj);
    delypos+=10;

    delypos+=delyshift;

    var xfrom = BreakPoint-30 +Math.floor(AlignmentStartPos);
    var xto = xfrom +60;
    //wt: REFERENCES SEQ
    for (let x=xfrom; x<xto; x++){
        //draw base:
        SVGObj= document.createElementNS(NS,"text");
        SVGObj.setAttribute("y", ysize+delypos+20);
        SVGObj.setAttribute("font-size", "14");
        if (x>=RightBsPos && x<RightBsPos+rightbs.length) SVGObj.setAttribute("fill", "rgb(0,0,250)");
        else SVGObj.setAttribute("fill", N_cl);
        SVGObj.textContent = locus_list[gene_i][x];
        SVGObj.setAttribute("x", 120+12*(x-xfrom));
        SVGObj.setAttribute("text-anchor", "middle");
        svg.appendChild(SVGObj);
    }
    //check and auto-edit sgRNA
    if (rightbs!=getSeq("RightBS")){
        locus2 = ReverseComplement(locus)
    }
    else{
        locus2 = locus
    }
    //draw base:
    for (let x=RightBsPos; x<RightBsPos+rightbs.length; x++){
        SVGObj= document.createElementNS(NS,"text");
        SVGObj.setAttribute("y", ysize+delypos);
        SVGObj.setAttribute("font-size", "14");
        SVGObj.setAttribute("fill", N_cl);
        SVGObj.textContent = locus_list[barcode][x];
        SVGObj.setAttribute("x", 120+12*(x-xfrom));
        SVGObj.setAttribute("text-anchor", "middle");
        svg.appendChild(SVGObj);
    }
    
    var imageElement = document.createElementNS(NS, "image");
    if (rightbs!=getSeq("RightBS")){
        imageElement.setAttribute("x", 95+12*(RightBsPos-xfrom )); // Set the x-coordinate of the image
    }    
    else{
        imageElement.setAttribute("x", 120+12*(RightBsPos+rightbs.length-xfrom)+2); // Set the x-coordinate of the image
    }
    imageElement.setAttribute("y", ysize + delypos -20); // Set the y-coordinate of the image
    imageElement.setAttribute("width", 20); // Set the width of the image
    imageElement.setAttribute("height", 20); // Set the height of the image
    imageElement.setAttribute("href", "crisprnano2/scissors.svg"); // Set the path to your image file
    svg.appendChild(imageElement);

    //reference:
    SVGObj= document.createElementNS(NS,"text");
    SVGObj.setAttribute("x", 1);
    SVGObj.setAttribute("y", ysize+delypos+20);
    SVGObj.setAttribute("font-size", "13");
    SVGObj.textContent += "REFERENCE 5'->3'";
    svg.appendChild(SVGObj);
    //line:
    SVGObj= document.createElementNS(NS,"path");
    SVGObj.setAttributeNS(null, "d", "M 5,"+(ysize+delypos+5.5)+" L 1200,"+(ysize+delypos+5.5));
    SVGObj.style.stroke=N_cl;
    SVGObj.setAttributeNS(null, "stroke-width", 1);
    svg.appendChild(SVGObj);
    delypos+=delyshift;
    var id1 = 1;

    for (let key in aln_dict_fil_off[barcode]){
        //aggregate WT
        for (let x=0; x<30*2; x++){
            //draw main track:
            if ((key[x]==locus_list[barcode][BreakPoint-region_analyse+x])||(key[x]=='N')||(key[x]=='-')||(typeof(key[x])=='undefined')){
                }
            }
        if (aln_dict_off[id][key][1]==1 && (Object.keys(no_indel_arr).length ==2)){
            for (let x=xfrom-10; x<xto-10; x++){
            //draw main track:
            if (Object.keys(no_indel_arr)[0][x]==Object.keys(no_indel_arr)[1][x]){
                if ((Object.keys(no_indel_arr)[0][x]==locus_list[barcode][BreakPoint-region_analyse+x])||(key[x]=='N')||(key[x]=='-')||(typeof(key[x])=='undefined')){
                }
                else {
                    SVGObj= document.createElementNS(svgns, "rect");
                    SVGObj.style.stroke=N_cl;
                    SVGObj.setAttribute("x", 115+12*(x-xfrom+10));
                    SVGObj.setAttribute("y", ysize+delypos-10);
                    SVGObj.setAttribute("width", "11");
                    SVGObj.setAttribute("height", "11");
                    SVGObj.setAttribute("fill", "rgb(255,255,255");
                    SVGObj.setAttribute("text-anchor", "middle");
                    SVGObj.setAttribute("pointer-events","none");
                    svg.appendChild(SVGObj);
                }
                SVGObj= document.createElementNS(NS, "text");
                    SVGObj.setAttribute("y", ysize+delypos);
                    SVGObj.setAttribute("font-size", "13");
                    SVGObj.setAttribute("font-weight", "800");
                    if (key[x]=="T"){SVGObj.textContent = key[x];
                        SVGObj.setAttribute("fill", T_cl);
                    }
                    else if (key[x]=="A"){SVGObj.textContent = key[x];
                        SVGObj.setAttribute("fill", A_cl);
                    }
                    else if (key[x]=="C"){SVGObj.textContent = key[x];
                        SVGObj.setAttribute("fill", C_cl);
                    }
                    else if (key[x]=="G"){SVGObj.textContent = key[x];
                        SVGObj.setAttribute("fill", G_cl);
                    }
                    else if (key[x]=="N"){SVGObj.textContent = key[x];
                        SVGObj.setAttribute("fill", N_cl);
                    }
                    else if (key[x]=="-"){SVGObj.textContent = key[x];
                        SVGObj.setAttribute("fill", N_cl);
                    }
                    SVGObj.setAttribute("x", 120+12*(x-xfrom+10));
                    SVGObj.setAttribute("text-anchor", "middle");
                    SVGObj.setAttribute("pointer-events","none");
                    svg.appendChild(SVGObj);
            }
            else {
                var fontsize1 = 2+ Math.floor(13*no_indel_arr[Object.keys(no_indel_arr)[0]]/(no_indel_arr[Object.keys(no_indel_arr)[0]]+no_indel_arr[Object.keys(no_indel_arr)[1]]))
                var fontsize2 = 2+ Math.floor(13*no_indel_arr[Object.keys(no_indel_arr)[1]]/(no_indel_arr[Object.keys(no_indel_arr)[0]]+no_indel_arr[Object.keys(no_indel_arr)[1]]))

                SVGObj= document.createElementNS(NS, "text");
                SVGObj.setAttribute("y", ysize+delypos+fontsize1-5);
                SVGObj.setAttribute("font-size", fontsize1);
                SVGObj.setAttribute("font-weight", "800");

                if (Object.keys(no_indel_arr)[0][x]=="T"){SVGObj.setAttribute("fill", T_cl);
                }
                else if (Object.keys(no_indel_arr)[0][x]=="A"){SVGObj.setAttribute("fill", A_cl);
                }
                else if (Object.keys(no_indel_arr)[0][x]=="C"){SVGObj.setAttribute("fill", C_cl);
                }
                else if (Object.keys(no_indel_arr)[0][x]=="G"){SVGObj.setAttribute("fill", G_cl);
                }
                else if (Object.keys(no_indel_arr)[0][x]=="N"){SVGObj.setAttribute("fill", N_cl);
                }
                else if (Object.keys(no_indel_arr)[0][x]=="-"){SVGObj.setAttribute("fill", N_cl);
                }
                SVGObj.textContent = Object.keys(no_indel_arr)[0][x];
                SVGObj.setAttribute("x", 120+12*(x-xfrom+10));
                SVGObj.setAttribute("text-anchor", "middle");
                SVGObj.setAttribute("pointer-events","none");
                svg.appendChild(SVGObj);

                SVGObj= document.createElementNS(NS, "text");
                SVGObj.setAttribute("y", ysize+delypos+15);
                SVGObj.setAttribute("font-size", 8);
                SVGObj.setAttribute("font-weight", "800");
                SVGObj.textContent = no_indel_arr[Object.keys(no_indel_arr)[1]] + " "+Object.keys(no_indel_arr)[1][x]
                SVGObj.setAttribute("x", 120+12*(x-xfrom+10));
                SVGObj.setAttribute("text-anchor", "middle");
                SVGObj.setAttribute("pointer-events","none");
                svg.appendChild(SVGObj);

                SVGObj= document.createElementNS(NS, "text");
                SVGObj.setAttribute("y", ysize+delypos+25);
                SVGObj.setAttribute("font-size", 8);
                SVGObj.setAttribute("font-weight", "800");
                SVGObj.textContent = no_indel_arr[Object.keys(no_indel_arr)[0]] + " " +Object.keys(no_indel_arr)[0][x]
                SVGObj.setAttribute("x", 120+12*(x-xfrom+10));
                SVGObj.setAttribute("text-anchor", "middle");
                SVGObj.setAttribute("pointer-events","none");
                svg.appendChild(SVGObj);

                SVGObj= document.createElementNS(NS, "text");
                SVGObj.setAttribute("y", ysize+delypos-5);
                SVGObj.setAttribute("font-size", fontsize2);
                SVGObj.setAttribute("font-weight", "800");

                if (Object.keys(no_indel_arr)[1][x]=="T"){SVGObj.setAttribute("fill", T_cl);
                }
                else if (Object.keys(no_indel_arr)[1][x]=="A"){SVGObj.setAttribute("fill", A_cl);
                }
                else if (Object.keys(no_indel_arr)[1][x]=="C"){SVGObj.setAttribute("fill", C_cl);
                }
                else if (Object.keys(no_indel_arr)[1][x]=="G"){SVGObj.setAttribute("fill", G_cl);
                }
                else if (Object.keys(no_indel_arr)[1][x]=="N"){SVGObj.setAttribute("fill", N_cl);
                }
                else if (Object.keys(no_indel_arr)[1][x]=="-"){SVGObj.setAttribute("fill", N_cl);
                }
                SVGObj.textContent = Object.keys(no_indel_arr)[1][x];
                SVGObj.setAttribute("x", 120+12*(x-xfrom+10));
                SVGObj.setAttribute("text-anchor", "middle");
                SVGObj.setAttribute("pointer-events","none");
                svg.appendChild(SVGObj);
            }
        }
        }
        else {
            for (let x=xfrom-10; x<xto-10; x++){
            //draw main track:
            if ((key[x]==locus_list[barcode][BreakPoint-region_analyse+x])||(key[x]=='N')||(key[x]=='-')||(typeof(key[x])=='undefined')){
                SVGObj= document.createElementNS(NS, "text");
                SVGObj.setAttribute("font-weight", "800");
            }
            else {
                SVGObj= document.createElementNS(svgns, "rect");
                SVGObj.style.stroke=N_cl;
                SVGObj.setAttribute("x", 115+12*(x-xfrom+10));
                SVGObj.setAttribute("y", ysize+delypos-10);
                SVGObj.setAttribute("width", "11");
                SVGObj.setAttribute("height", "11");
                SVGObj.setAttribute("fill", "rgb(255,255,255");
                SVGObj.setAttribute("text-anchor", "middle");
                SVGObj.setAttribute("pointer-events","none");
                svg.appendChild(SVGObj);
                SVGObj= document.createElementNS(NS, "text");
                SVGObj.setAttribute("font-weight", "800");
            }
            
            SVGObj.setAttribute("y", ysize+delypos);
            SVGObj.setAttribute("font-size", "13");

            if (key[x]=="T"){SVGObj.textContent = key[x];
                SVGObj.setAttribute("fill", T_cl);
            }
            else if (key[x]=="A"){SVGObj.textContent = key[x];
                SVGObj.setAttribute("fill", A_cl);
            }
            else if (key[x]=="C"){SVGObj.textContent = key[x];
                SVGObj.setAttribute("fill", C_cl);
            }
            else if (key[x]=="G"){SVGObj.textContent = key[x];
                SVGObj.setAttribute("fill", G_cl);
            }
            else if (key[x]=="N"){SVGObj.textContent = key[x];
                SVGObj.setAttribute("fill", N_cl);
            }
            else if (key[x]=="-"){SVGObj.textContent = key[x];
                SVGObj.setAttribute("fill", N_cl);
            }
            SVGObj.setAttribute("x", 120+12*(x-xfrom+10));
            SVGObj.setAttribute("text-anchor", "middle");
            SVGObj.setAttribute("pointer-events","none");
            svg.appendChild(SVGObj); 
            }
        }
        
        var image_loc = 0;
        for (let x=xfrom-10; x<xto-10; x++){
            if (x>0){
            //draw insert:
            SVGObj= document.createElementNS(svgns, "rect");
            if ('ACTG'.includes(key[x+region_analyse*2])){
                if (image_loc == 0){
                    const line = document.createElementNS(NS, "line");
                    // Set line attributes to make it vertical
                    line.setAttribute("x1", 120+12*(x-xfrom+10)-18);
                    line.setAttribute("y1", ysize+delypos-14);
                    line.setAttribute("x2", 120+12*(x-xfrom+10)-18);
                    line.setAttribute("y2", ysize+delypos+20);
                    line.setAttribute("stroke", "blue");
                    line.setAttribute("stroke-width", "3");
                    svg.appendChild(line);
                    image_loc =1;
                }
                SVGObj.style.stroke=T_cl;
                SVGObj.setAttribute("x", 120+12*(x-xfrom+9)-4);
                SVGObj.setAttribute("y", ysize+delypos+4);
                SVGObj.setAttribute("width", "12");
                SVGObj.setAttribute("height", "12");
                SVGObj.setAttribute("fill", "rgb(255,255,255");
                SVGObj.setAttribute("text-anchor", "middle");
                SVGObj.setAttribute("pointer-events","none");
                svg.appendChild(SVGObj);
            }

            SVGObj= document.createElementNS(NS,"text");
            SVGObj.setAttribute("x", 120+12*(x-xfrom+9)+1);
            SVGObj.setAttribute("y", ysize+delypos+15);
            SVGObj.setAttribute("font-size", "13");
            SVGObj.setAttribute("fill", N_cl);
            SVGObj.textContent = key[x+region_analyse*2];
            SVGObj.setAttribute("text-anchor", "middle");
            SVGObj.setAttribute("pointer-events","none");
            svg.appendChild(SVGObj);
            }
        }
        
        SVGObj= document.createElementNS(NS,"text");
        SVGObj.setAttribute("x", 1);
        SVGObj.setAttribute("y", ysize+delypos);
        SVGObj.setAttribute("font-size", "14");
        SVGObj.textContent += "GROUP " +id1;
        svg.appendChild(SVGObj);

        SVGObj= document.createElementNS(NS,"text");
        SVGObj.setAttribute("x", 10+ 120+24*(30)+2 );
        SVGObj.setAttribute("y", ysize+delypos);
        SVGObj.setAttribute("font-size", "14");
        // Count INDEL's length
        var gap_len1 = key.substring(region_analyse*2 +1, region_analyse*4).replace(/-/g, "").replace(/\s+/g, "").length -  (key.substring(0, region_analyse*2).split("-").length-1)

        SVGObj.textContent +="TYPE: "+ aln_type[aln_dict_off[barcode][key][1]] + ", (" + gap_len1 + " bp)" +" | " +aln_dict_fil_off[barcode][key] +"  Reads, " + (aln_dict_fil_off[barcode][key]/summary_track_off[barcode][7]*100).toFixed(2) + " %";
        svg.appendChild(SVGObj);
        id1+=1;
        delypos+=delyshift;
    }
     AlignmentPrecalc_off[gene_i] = document.getElementById("DIV_alignment_off").innerHTML;
}

//Save HTML, all the required variables store in BLOB and load later
function SaveProject() {
    var aln_data = {genename: document.getElementsByName("GeneName")[0].value, BreakPoint: BreakPoint , files_name:files_name, region_analyse: region_analyse,  RightBsPos: RightBsPos, locus: locus, rightbs: rightbs, rtt: rtt, targetingOligo1: targetingOligo1 ,d_edit: d_edit, p_edit: p_edit, MutationThreshold: MutationThreshold, PhredThreshold: PhredThreshold,
    aln_dict: aln_dict, aln_dict_fil: aln_dict_fil, aln_dict_off: aln_dict_off,aln_dict_fil_off: aln_dict_fil_off,phred_array: phred_array, gcContent: gcContent, length_array:length_array}
    var blob = new Blob([JSON.stringify(aln_data)], { type: 'application/json'});  
    var reader = new window.FileReader();
    targetingOligo
    reader.onloadend = function(){
        base64data = reader.result;
        base64data = base64data.split(",")[1]; //remove header
        var html = "<meta http-equiv='refresh' content='0; url=https://crisprnano.de/Edit-o-Matic.html#"+base64data+"'>";
        html += "<html><body>"+document.getElementById("DIV_piecharts").innerHTML+"</body></html>";
        var blob2 = new Blob([html], {type: 'text/plain'});
        var a = document.createElement('a');
        a.download = "Result_"+document.getElementsByName("GeneName")[0].value+".html";
        a.href = window.URL.createObjectURL(blob2);
        a.textContent = 'Click here to save';
        a.dataset.downloadurl = ['text/plain', a.download, a.href].join(':');
        document.getElementById("save").appendChild(a);
        a.click();
    }
    reader.readAsDataURL(blob);
}

// This will load all offline variables

function LoadData(){
    if (window.location.hash) {
        AlignmentPrecalc = new Array(96);
        for (let i=0; i<96; i++){
            sum_track[i] = 0;
            summary_track[i] = Array(9); 
        }
        var store_data = atob(window.location.hash.substr(1));
        store_data = JSON.parse(store_data)
        //Update GUI and variables
        BreakPoint = store_data.BreakPoint;
        files_name = store_data.files_name;
        RightBsPos = store_data.RightBsPos;
        MutationThreshold = store_data.MutationThreshold;
        document.getElementById("allelethreshold").value = MutationThreshold;
        region_analyse = store_data.region_analyse;
        document.getElementById("region_analyse").value = 2*region_analyse
        rtt = store_data.rtt;
        document.getElementById("RTT").value = rtt;
        targetingOligo1 = store_data.targetingOligo1;
        document.getElementById("TargetingOligo").value = targetingOligo1;
        PhredThreshold = store_data.PhredThreshold;
        document.getElementById("phredthreshold").value = PhredThreshold;
        document.getElementById("GeneName").value = store_data.genename;
        p_edit = store_data.p_edit;
        document.getElementById("p_edit").value = store_data.p_edit;
        d_edit = store_data.d_edit;
        document.getElementById("d_edit").value = store_data.d_edit;
        rightbs = store_data.rightbs;
        document.getElementById("RightBS").value = store_data.rightbs;
        locus = store_data.locus;
        document.getElementById("locus").value = store_data.locus;
        aln_dict = store_data.aln_dict;
        aln_dict_fil = store_data.aln_dict_fil;
        phred_array = store_data.phred_array;
        gcContent = store_data.gcContent;
        length_array = store_data.length_array;
        for (let id=0;id <96;id++){
            for (let key in aln_dict_fil[id]){
                var key1 = key.replace(/Â/g, "");
                key1 = key1.replace(/↵/g, "\n");
                if (key1!=key){
                    aln_dict_fil[id][key1] = aln_dict_fil[id][key]
                    delete aln_dict_fil[id][key]
                }
            }
            for (let key in aln_dict[id]){
                var key1 = key.replace(/Â/g, "");
                key1 = key1.replace(/↵/g, "\n");
                if (key1!=key){
                    aln_dict[id][key1] = aln_dict[id][key]
                    delete aln_dict[id][key]
                }
            }            
            Pre_PlotAlignment(id, locus);
            PlotAlignment(id, locus);
            //Update for wrong encoding entries
        }
        DrawPie();
        DrawPie_rima();
        SelectClone(0);
        window.location.hash = "";
    }
}

function SaveReport() {
    //alert(svg.innerHTML);
    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.aoa_to_sheet(summary_track_select);
    XLSX.utils.book_append_sheet(workbook, worksheet, "Sheet1");
    const excelBuffer = XLSX.write(workbook, { type: "array", bookType: "xlsx" });
    const bb = new Blob([excelBuffer], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
    // var bb = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    var a = document.createElement('a');
    a.download = document.getElementsByName("GeneName")[0].value+".xlsx";
    a.href = window.URL.createObjectURL(bb);
    a.textContent = 'Click here to save';
    a.dataset.downloadurl = ['text/plain', a.download, a.href].join(':');
    document.getElementById("save").appendChild(a);
    a.click();
}

function SaveReportcsv() {
    const now = new Date();
    var config_data = "# Analysis on: " + now.toString()+"\n";
    config_data += "# Gene: " +document.getElementsByName("GeneName")[0].value +"\n";
    config_data += "# sgRNA:" + rightbs +"\n";
    config_data += "# Referfence: " + locus +"\n";
    config_data += "# Target Oligo: " + targetingOligo1 +"\n";
    config_data += "# RTT: " + rtt +"\n";
    config_data += "# Desired Edit: " + d_edit +"\n";
    config_data += "# Partial Edit: " + p_edit +"\n";
    config_data += "# Region Analyser: " + 2*region_analyse +"\n";
    config_data += "# Indel Threshold: " + MutationThreshold +"\n";
    config_data += "# Phred Threshold: " + PhredThreshold +"\n";
    const csvContent = config_data + summary_track_select.map(row => row.join("\t")).join("\n");
    var bb = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    var a = document.createElement('a');
    a.download = document.getElementsByName("GeneName")[0].value+".csv";
    a.href = window.URL.createObjectURL(bb);
    a.textContent = 'Click here to save';
    a.dataset.downloadurl = ['text/plain', a.download, a.href].join(':');
    document.getElementById("save").appendChild(a);
    a.click();
}

function SaveSVGAlignment()
{
    var svg = document.getElementById("DIV_alignment");
    var svgContent = svg.innerHTML.replace(/&nbsp;/g, ' ');
    var bb = new Blob([svgContent], {type: 'text/plain'});
    var a = document.createElement('a');
    a.download = document.getElementsByName("GeneName")[0].value+" "+GetWellPos(CurrentAlignment)+".svg";
    a.href = window.URL.createObjectURL(bb);
    a.textContent = 'Click here to save';
    a.dataset.downloadurl = ['text/plain', a.download, a.href].join(':');
    document.getElementById("save").appendChild(a);
    a.click();
}

function PrintSVG()
{
    var printWindow = document.open('', 'Print', 'width=900, height=550');
    printWindow.document.writeln(document.getElementById("DIV_piecharts").innerHTML);
    printWindow.document.close();
    printWindow.print();
    printWindow.close();
}

function ReverseString(str) {
        return str.split('').reverse().join('')
    }

//Convertion standard alignment key to original 1D format WRT ref[breakingpoint ]    
function KeytoSeq(seq_key, size= 40){
    const ref1 = seq_key.split('\n')[0].replace(/-/g, "");
    const ins1 = seq_key.split('\n')[1]
    var ins_trim = ins1.trim()
    var new_key
    if (ins_trim == ''){
        new_key = ref1.substring(RightBsPos-size, RightBsPos+size)        
    }
    else{
        new_key = ref1.substring(0, ins1.indexOf(ins_trim)) + ins_trim + ref1.substring(ins1.indexOf(ins_trim), ref1.length)
    }
    return [new_key, seq_key]
}

function PrintSVGAlignment(){
    var printWindow = document.open('', 'Print', 'width=1250, height=400');
    printWindow.document.writeln(document.getElementById("DIV_alignment").innerHTML);
    printWindow.document.close();
    printWindow.print();
    printWindow.close();
}

function FindGRNA(gene) {
    var fileUrl
    if (document.URL.includes('www')){
        fileUrl = 'https://www.crisprnano.de/tkov3_guide_sequence.csv';
    }
    else {
        fileUrl = 'https://crisprnano.de/tkov3_guide_sequence.csv';
    }
    sglib = document.getElementById("lib_Select").value;

    document.getElementById("lib_Select").addEventListener("change", function () {
        sglib = this.value;
        console.log("Global sglib updated to:", sglib);
    });


    if (document.URL.includes('www')){
        if (sglib == "Lib Brunello"){
            fileUrl = "https://www.crisprnano.de/brunello.csv"
        }
        else if (sglib== "Lib Bassik"){
            fileUrl = "https://www.crisprnano.de/bassik.csv"
        }
    }
    else {
        if (sglib == "Lib Brunello"){
            fileUrl = "https://crisprnano.de/brunello.csv"
        }
        else if (sglib== "Lib Bassik"){
            fileUrl = "https://crisprnano.de/bassik.csv"
        }
    }


    // Fetch the file
    fetch(fileUrl)
    .then(response => {
        // Check if the response is successful
        if (!response.ok) {
        throw new Error('Network response was not ok ' + response.statusText);
        }
        return response.text(); // Read the response as text
    })
    .then(data => {
        // Handle the text data here
        CRISPRlib = data;
    })
    .catch(error => {
        // Handle errors
        console.error('There was a problem with the fetch operation:', error);
    });
    
    var table = "";

    if (gene.length >= 3)
    {
        //correct upper / lower case mouse / human:
        var geneUpperCase = gene.toUpperCase();
        var geneLowerCase = gene.toLowerCase();
        gene = geneUpperCase;
        var pos=0, hit;
        while (pos<CRISPRlib.length && (hit = CRISPRlib.indexOf(gene, pos)) != -1)
        {
            var line="";
            pos = hit;
            while (pos<CRISPRlib.length && CRISPRlib[pos] != "\n"){
                line += CRISPRlib[pos++];
            }

            if (hit==0 || CRISPRlib[hit-1]=="\n"){
                line = line.split("\t");
                if (line.length >= 2) {
                    table += "<button onclick='SelectGRNA(\""+line+"\");'>"+sglib+  "  GENE:"+line[0]+"   gRNA:"+line[1]+"   Locus/ENSEMBL_ID:"+line[2]+"   type:"+line[3]+"</button><br>";
                }
            }
        }
        if (CRISPRlib == "") table = "please wait for the gRNA library to be loaded.<br>";
        table += "<button onclick='SelectGRNA();'>Enter custom target site</button>";
    }

    //move gene_auto_complete to input:
    var gene_auto_complete = document.getElementById("gene_auto_complete");
    var gene_input = document.getElementsByName("GeneName")[0];
    gene_auto_complete.innerHTML = table;
    var x = gene_input.offsetLeft;
    var y = gene_input.offsetTop+30;
    gene_auto_complete.style.left = x;
    gene_auto_complete.style.top = y;
    if (table=="") gene_auto_complete.style.display = "none";
    else gene_auto_complete.style.display = "";
}

function SelectGRNA(line){
    document.getElementById("gene_auto_complete").style.display = "none";
    document.getElementById("RightBS").value = "";
    if (!line) return;
    line = line.split(",");
    var gene = line[0];
    var ts = line[1];
    var fwd = line[2];
    var rev = line[3];
    document.getElementById("RightBS").value = ts;
    document.getElementById("GeneName").value = gene;
    getFastaSequence()
}

function Hide_auto_complete(){
    gene_auto_complete.style.display = "none";
}

// Check micro homology for given sequence 
// input: our alignment dictionary element does not contain insertion track

function Check_RIMA(sequence_seq){
    var micro_homology = ''
    const startIndex = sequence_seq.indexOf('-');
    const endIndex = sequence_seq.lastIndexOf('-') + 1;
    const insert_size = sequence_seq.split('\n')[1].trim().length
    var ref_seq = locus.substring(10, sequence_seq.length + 10)
    if (startIndex !=0){
        for (let i = startIndex; i < endIndex; i++) {
            if (ref_seq[i]==sequence_seq[i+endIndex-startIndex]){
                micro_homology+=ref_seq[i]
            }
            else{
                break
            }
        }
    }
    return [micro_homology, startIndex, endIndex, insert_size];   
}

// Check duplication for insertion sequence 
// input: our alignment dictionary element contains insertion track
function Check_duplication(sequence_seq){
    var duplicate = false
    const main_track = sequence_seq.split('\n')[0]
    const insertion = sequence_seq.split('\n')[1]
    const insertion_trim = insertion.trim()
    var index_in = 0
    if (insertion_trim ){
        index_in = insertion.indexOf(insertion_trim)
        duplicate = (main_track.substring(index_in, index_in+insertion_trim.length)==insertion.substring(index_in, index_in+insertion_trim.length)||main_track.substring(index_in-insertion_trim.length, index_in)==insertion.substring(index_in, index_in+insertion_trim.length))
    }
    return [duplicate, index_in, insertion_trim.length];   
}

function Check_ins_RTT(sequence_seq, buff_size = 5){
    // This function will check the insertion track expand it to the both site of insertion position then use global alignment to RTT, 
    // if there is better matching, shift the cutting site to the maximum point
    // Update the new aligment entry to the alignment dictionary
    var ms = 1 // match score
    var mms = -1//mismatch score
    var gapo = -3  // gap open score
    var gape = -1  // gap extent score
    var shifted = false
    const main_track = sequence_seq.split('\n')[0]
    const insertion = sequence_seq.split('\n')[1]
    const insertion_trim = insertion.trim() 
    var index_in 
    var seq_new = sequence_seq
    var ins_new
    var rtt_ins =""
    var fmt
    if (insertion_trim ){
        index_in = insertion.indexOf(insertion_trim)
        if (index_in >buff_size && index_in< (main_track.length -buff_size)){
            var insertion_buff =  main_track.slice(index_in-buff_size, index_in) + insertion_trim + main_track.slice(index_in, index_in +buff_size)
        }
        try{
            if (typeof insertion_buff.length !== undefined){
                var rst = bsa_align(insertion_buff, rtt, [ms, mms], [gapo, gape], is_local = true);
            // update new insertion position 
                if (rst[1]!=buff_size){
                ins_new = insertion_buff.slice(rst[1], rst[1]+insertion_trim.length)
                shifted = true
                }
                else{
                    ins_new = insertion_trim
                }
                var rst1 = bsa_align(ins_new, rtt, [ms, mms], [gapo, gape], is_local = false);
                fmt = bsa_cigar2gaps(ins_new, rtt, rst1[1], rst1[2]);
                ins_new = fmt[0]
                rtt_ins = fmt[1]
                var index_ins_gap = index_in - ins_new.search(/[A-Z]/);
                //update the dictionary with new insertion position
                seq_new = main_track +'\n'+  ''.padStart(index_ins_gap + rst[1]- buff_size, ' ') + ins_new  + ''.padStart((main_track.length - (index_ins_gap + rst[1]- buff_size +ins_new.length)), ' ') +'\n'+ ''.padStart(index_ins_gap + rst[1]- buff_size -7, ' ') +'(RTT)  ' + rtt_ins  + ''.padStart((main_track.length - (index_ins_gap + rst[1]- buff_size +ins_new.length)), ' ') +'\n'
                }
            }
        catch (error){}
    }    
    return [shifted, ins_new, insertion_trim.length, seq_new, index_ins_gap + rst[1]- buff_size + ins_new.search(/[A-Z]/)];   
}

function Check_ins_RTT2(sequence_seq, common_post){
    // This function will check the insertion track again base on the RTT shifted position
    var ms = 1 // match score
    var mms = -1//mismatch score
    var gapo = -3  // gap open score
    var gape = -1  // gap extent score
    const main_track = sequence_seq.split('\n')[0]
    const insertion = sequence_seq.split('\n')[1]
    const insertion_trim = insertion.replace(/-/g, "").replace(/\s+/g, "")
    var index_in 
    var seq_new = sequence_seq
    var seq_new1
    var ins_new
    var shifted = false
    var insertion_buff
    var buff_size = 5
    var index_ins_gap 
    if (insertion_trim){
        index_in = insertion.indexOf(insertion_trim)
        var insertion_buff =  main_track.slice(index_in-5, index_in) + insertion_trim + main_track.slice(index_in, index_in +5)
        if (index_in <common_post){
            if (insertion_trim.substring(0, common_post-index_in)== main_track.substring(index_in, common_post)){
                ins_new = insertion_trim.substring(common_post-index_in, insertion_trim.length) + insertion_trim.substring(0, common_post-index_in)
                shifted = true
                index_in = common_post
            }
        }
        else if (index_in > common_post){
            if (insertion_trim.substring(insertion_trim.length-(index_in-common_post), insertion_trim.length)== main_track.substring(common_post,index_in)){
                ins_new = main_track.substring(common_post,index_in) + insertion_trim.substring(0, insertion_trim.length-(index_in-common_post))
                shifted = true
                index_in = common_post
            }
        }
        if (shifted){
            if (sequence_seq.split('\n')[2].includes('RTT')){
            try{
                if (typeof insertion_buff.length !== undefined){
                    var rst = bsa_align(insertion_buff, rtt, [ms, mms], [gapo, gape], is_local = true);
                // update new insertion position 
                    var rst1 = bsa_align(ins_new, rtt, [ms, mms], [gapo, gape], is_local = false);
                    fmt = bsa_cigar2gaps(ins_new, rtt, rst1[1], rst1[2]);
                    ins_new = fmt[0]
                    rtt_ins = fmt[1]
                    index_ins_gap = index_in - ins_new.search(/[A-Z]/);
                    //update the dictionary with new insertion position
                }
            }
            catch (error){
            }
            seq_new = main_track +'\n'+  ''.padStart(index_ins_gap + rst[1]- buff_size, ' ') + ins_new  + ''.padStart((main_track.length - (index_ins_gap + rst[1]- buff_size +ins_new.length)), ' ') +'\n'+ ''.padStart(index_ins_gap + rst[1]- buff_size -7, ' ') +'(RTT)  ' + rtt_ins  + ''.padStart((main_track.length - (index_ins_gap + rst[1]- buff_size +ins_new.length)), ' ') +'\n'
            }
            else {
                seq_new = main_track +'\n'+  ''.padStart(index_in, ' ') + ins_new  + ''.padStart((main_track.length - (index_in+ ins_new.length)), ' ')
            }
        }
    }
    return [shifted, ins_new, insertion_trim.length, seq_new, index_ins_gap];   
}

//Toogle help text display 
function toggleHelp(id) {
  document.getElementById("help" + id).classList.toggle("show");
}

function Start(){
    document.getElementById("progress").style.display = '';
    //Reset all variables
    files_name = []
    for (var i=0; i<96; i++) {
        phred_array[i] = {}
        length_array[i] = {}
        aln_dict[i] = {}
        aln_dict_fil[i] = {}
        gcContent[i] = {}
    }
    AlignmentPrecalc = new Array(96);
    for (var i=0; i<96; i++){
        sum_track[i] = 0;
        summary_track[i] = Array(9); 
    }

    d_edit = getSeq("d_edit"); // desired edit
    p_edit = getSeq("p_edit"); //partial edit

    //Check 3 times locus
    if (locus == ''){
        locus = getSeq("Locus"); //reference sequence
    }

    if (locus==''){
        getFastaSequence();
    }

    if (rtt == ''){
        rtt = getSeq("RTT"); //reference sequence
    }
    rightbs = getSeq("RightBS"); // sgRNA seq  
    
    MutationThreshold = document.getElementsByName("MutationThreshold")[0].value*1;
    region_analyse = parseInt((0.5*document.getElementsByName("region_analyse")[0].value).toFixed(0), 10);

    //Find Target site in the reference sequence/locus:
    if (rightbs.length == 0){
        alert("No target site was entered. Please enter a valid sequence");
        return;
    }
    if (locus.includes(rightbs)){
        RightBsPos = locus.search(rightbs);
    }
    else if (locus.includes(ReverseComplement(rightbs))){
        rightbs = ReverseComplement(rightbs);
        RightBsPos = locus.search(rightbs);
    }
    else if (locus.includes(ReverseString(rightbs))){
        rightbs = ReverseString(rightbs);
        RightBsPos = locus.search(rightbs);
    }
    else if (locus.includes(ReverseString(ReverseComplement(rightbs)))){
        rightbs = ReverseString(ReverseComplement(rightbs));
        RightBsPos = locus.search(rightbs);
    }
    else {
        alert("The target site was not found in the reference sequence. Please enter a valid sequence");
        document.getElementById("progress").style.display = 'Please check the input form';
        return
    }

    //Get advanced PE 
    if ((preRTT == '')||(sufRTT == '')||(pbs == '')){
        preRTT = getSeq("preRTT"); // preRTT seq  
        sufRTT = getSeq("sufRTT"); // sufRTT seq  
        pbs = getSeq("PBS"); // PBS seq  
    }
    //TODO: Add validation function later
    if ((preRTT)&&((sufRTT)||(pbs))){
        var pre_rtt_index = locus.search(preRTT)
        var pre_rtt_index_rv = locus.search(ReverseComplement(preRTT))
        if (pre_rtt_index==-1&&pre_rtt_index_rv==-1){
            alert('PreRTT not found, please check your preRTT input')
        }
        else if (pre_rtt_index==-1){
            preRTT = ReverseComplement(preRTT)
            pre_rtt_index = pre_rtt_index_rv
        } 
        // Use pbs
        if (pbs){
            var pbs_index = locus.search(pbs)
            var pbs_index_rv = locus.search(ReverseComplement(pbs))
            if (pbs_index==-1&&pbs_index_rv==-1){
                alert('PBS not found, please check your PBS input')
            }
            else if (pbs_index==-1){
                pbs = ReverseComplement(pbs)
                pbs_index = pbs_index_rv
            } 
            locus_pe = locus.substring(0, pre_rtt_index + preRTT.length) + locus.substring(pbs_index, locus.length)
        }
    }
    
    //check other field 
    if (region_analyse*1>80){
        alert('Please reduce the region analyse value');
        return
    }
    
    //Update new locus, and sgRNA position 
    locus_check1 = locus.substring(RightBsPos -region_analyse*1-10, RightBsPos -region_analyse*1)
    locus_check2 = locus.substring(RightBsPos + region_analyse*1, RightBsPos +region_analyse*1 +10)

    locus = locus.substring(RightBsPos -region_analyse*1, RightBsPos + 20 +region_analyse*1)

    RightBsPos = locus.search(rightbs);
    //breaking point on locus 
    if (rightbs!=rightbs != getSeq("RightBS")){
        BreakPoint = RightBsPos + 10;
    }
    else{
        BreakPoint = RightBsPos + 20 
    }
    locus_backup = locus
    if (locus_pe) locus = locus_pe

    var evt = document.getElementById('files');
    files = evt.files;
    for (let i=0; i<files.length; i++){
        files_name.push(files[i].name)
    }

    if (files.length <= 0) {
        alert("No files were specified. Please upload your fastq files");
        return;
    }
    
    CurrentFileId = 0;
    CurrentFileChunk = 0;
    ReadNextFileChunk();
}

function Start2(){
    document.getElementById("progress1").style.display = '';
    gene_list = document.getElementsByName("GeneName_list")[0].value.split(',')
    rightbs = getSeq("RightBS"); // sgRNA seq
    region_analyse = (0.5*document.getElementsByName("region_analyse")[0].value).toFixed(0);
    gene_list.unshift(document.getElementsByName("GeneName")[0].value)

    //reset all varibles
    for (var i=0; i<5; i++){
        sum_track_off[i] = 0;
        summary_track_off[i] = Array(8); 
    }
    AlignmentPrecalc_off = new Array(5);
    for (let i=0; i<5; i++) {
        aln_dict_off[i] = {}
        aln_dict_fil_off[i] = {}
    }

    //Score of OFF target reference
    var ms = 1 // match score
    var mms = -1 //mismatch score
    var gapo = -2  // gap open score
    var gape = -1  // gap extent score

    //Find Target site in the reference sequence/locus:
    if (rightbs.length == 0){
        alert("No target site was entered. Please enter a valid sequence");
        return;
    }
    if (!locus_list.includes(locus)){
        locus_list.unshift(locus)
    }

    locus_list1[0] = document.getElementById("RightBS").value.replace(/[\s\n]+/g, '').toUpperCase();
    locus_list1[1] = document.getElementById("sgRNA1").value.replace(/[\s\n]+/g, '').toUpperCase();
    locus_list1[2] = document.getElementById("sgRNA2").value.replace(/[\s\n]+/g, '').toUpperCase();
    locus_list1[3] = document.getElementById("sgRNA3").value.replace(/[\s\n]+/g, '').toUpperCase();
    locus_list1[4] = document.getElementById("sgRNA4").value.replace(/[\s\n]+/g, '').toUpperCase();

    for (let i = 0; i<locus_list.length; i++){

        if (locus_list[i].includes(locus_list1[i])){
            RightBsPos_off[i] = locus_list[i].indexOf(locus_list1[i])
            BreakPoint_off[i] = RightBsPos_off[i] +10
        }
        else if (locus_list[i].includes(ReverseComplement(locus_list1[i]))){
            locus_list1[i] = ReverseComplement(locus_list1[i])
            RightBsPos_off[i] = locus_list[i].indexOf(locus_list1[i])
            BreakPoint_off[i] = RightBsPos_off[i] +20
        }

        locus_list[i] = locus_list[i].substring(RightBsPos_off[i] -region_analyse*1, RightBsPos_off[i] + 20 +region_analyse*1)
        RightBsPos_off[i] = locus_list[i].indexOf(locus_list1[i])
        if (locus_list[i].includes(locus_list1[i])){
            BreakPoint_off[i] = RightBsPos_off[i] +10
        }
        else if (locus_list[i].includes(ReverseComplement(locus_list1[i]))){
            BreakPoint_off[i] = RightBsPos_off[i] +20
        }
        // }
    }
    for (let i = 0; i<locus_list.length; i++){
        locus_check1_off[i] = locus_list[i].substring(0, 10)
        locus_check2_off[i] = locus_list[i].substring(locus_list[i].length -10, locus_list[i].length)
    }
      

    CurrentFileId_off = CurrentAlignment;
    CurrentFileChunk = 0;
    ReadNextFileChunk_off();
}

function containsAny(string, array) {
  return array.every(item => string.includes(item));
}

//Function to find most popular to tune insertion
function findMostPopular(arr) {
    const countMap = new Map();
    // Count occurrences of each element
    for (let elem of arr) {
        countMap.set(elem, (countMap.get(elem) || 0) + 1);
    }
    let maxCount = 0;
    let mostPopular = null;

    for (let [key, count] of countMap) {
        if (count > maxCount) {
            maxCount = count;
            mostPopular = key;
        }
    }
    return mostPopular;
}

var bst_nt5 = [
    4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
    4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
    4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
    4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
    4, 0, 4, 1,  4, 4, 4, 2,  4, 4, 4, 4,  4, 4, 4, 4,
    4, 4, 4, 4,  3, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
    4, 0, 4, 1,  4, 4, 4, 2,  4, 4, 4, 4,  4, 4, 4, 4,
    4, 4, 4, 4,  3, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
    4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
    4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
    4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
    4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
    4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
    4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
    4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
    4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4
];

function binQualityScores(qualityScores, resolution) {
            const bins = new Array(Math.ceil(40 / resolution)).fill(0);
            for (let score of qualityScores) {
                const binIndex = Math.floor(score / resolution);
                bins[binIndex]++;
            }
            return bins;
        }

function calculateGCContent(sequence) {
    let gcCount = 0;
    for (let i = 0; i < sequence.length; i++) {
        if (sequence[i] === 'G' || sequence[i] === 'C') {
            gcCount++;
        }
    }
    return (gcCount / sequence.length) * 100;
}

function divide_zero(a, b) {
    if (b === 0) {
        return 0;
    } else {
        return a / b;
    }
}

var currenttab = 0;
TabClicked(0);

var RightBsPos=0;

//raw aligned dictionary
var aln_dict = Array(96);

//candidate seq dictionary for classifier
var aln_dict_ML = Array(96);
//filtered aligned dictionary
var aln_dict_fil = Array(96)

var AlignmentPrecalc
var locus = '';
// modified locus for advanced Prime Editing workflow!
var locus_pe = '';
// locus backup for advanced Prime Editing workflow!
var locus_backup = '';
var preRTT = '';
var sufRTT = '';
var pbs = '';

var targetingOligo1 = ''; // KI sequence
var locus_check1 = ''; //adaptive ref pair
var locus_check2 = ''; //adaptive ref
var locus_check1_off = Array(4); //adaptive ref pair
var locus_check2_off = Array(4); //adaptive ref
var d_edit 
var p_edit 
var rtt = ''
var files;
var files_name = [];
var reader;
var CurrentFileId;
var CurrentFileId_off;
var MutationThreshold = 0.1
var BreakPoint;
var rightbs;

var PhredThreshold = 40; // 7 +33

var sum_track = Array(96)
var summary_track = Array(96)
var summary_track_select = Array(97)
summary_track_select[0] = ["Sample", "%Oligo (KI)", "% WT", "% In-frame", "% Out-frame", "% Desired Edit","% Partial Edit",  "# Total Aligned Read"]
var phred_array = Array(96)
var length_array = Array(96)
var region_analyse = 80;

// Offtarget analyzer
var CurrentAlignment_off = 0;
var CurrentAlignment = 0;

var AlignmentPrecalc_off = new Array(5);
var AlignmentPrecalc_bulk
var locus_list = [];
var locus_list1 = []; // gene unique regions

var summary_track_off = Array(5)

//raw aligned dictionary off target
var aln_dict_off = Array(5);
//filtered aligned dictionary off target
var aln_dict_fil_off = Array(5)

var RightBsPos_off = [0, 0, 0, 0, 0];
var BreakPoint_off = [0, 0, 0, 0, 0]
var sum_track_off = Array(5)

var RestFromLastChunk = "";
var chunksize = 128*1024;
var gene_list = ''
var genotype = Array(96)
var aln_dict_bulk 
var gcContent = Array(96)
var bulk_threshold = 1

var no_indel = Array(96) 
var no_indel_arr = Array(96)
var inf_indel =  Array(96)
var out_indel = Array(96)
var out_indel_arr = Array(96)
var targetingOligo = Array(96)
var targetingOligo_arr = Array(96)
var rima_hist_all = Array(96)
var oli_aligned = false 
var str_oli = ''

const T_cl = "rgb(255,0,0)"
const A_cl = "rgb(0,150,0)"
const C_cl ="rgb(0,0,255)"
const G_cl = "rgb(200, 100, 0)"
const N_cl = "rgb(0, 0, 0)"
const KI_1 = "rgb(154, 34, 93)"
const KI_2 = "rgb(31, 89, 143)"

//Using local files
var CRISPRlib = ""
var sglib;

const toggleButton = document.getElementById('toggleButton');
const sgRNAContainer = document.getElementById('sgRNAContainer');
toggleButton.addEventListener('click', function() {
    sgRNAContainer.classList.toggle('hidden');
});

const optional_para = document.getElementById('optional_para');
const optional_para_Container = document.getElementById('optional_para_Container');

optional_para.addEventListener('click', function() {
    optional_para_Container.classList.toggle('hidden');
});

const optional_para_PE = document.getElementById('setup_PE');
const optional_para_Container_PE = document.getElementById('optional_para_Container_PE');

optional_para_PE.addEventListener('click', function() {
    optional_para_Container_PE.classList.toggle('hidden');
});
LoadData();
</script>
</html>